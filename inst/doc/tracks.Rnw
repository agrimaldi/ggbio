%\VignetteIndexEntry{Buidling tracks}
%\VignetteDepends{}
%\VignetteKeywords{visualization utilities}
%\VignettePackage{ggbio}
\documentclass[10pt]{article}

% \usepackage{times}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}

% \SweaveOpts{width = 2.5, height = 2}


\textwidth=6.5in
\textheight=8.5in
\parskip=.3cm
\parindent = 0cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\setkeys{Gin}{width=0.95\textwidth}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioc}{\software{Bioconductor}}
\newcommand{\IRanges}{\Rpackage{IRanges}}
\newcommand{\biovizBase}{\Rpackage{biovizBase}}
\newcommand{\ggbio}{\Rpackage{ggbio}}
\newcommand{\visnab}{\Rpackage{visnab}}
\newcommand{\ggplot}{\Rpackage{ggplot2}}
\newcommand{\grid}{\Rpackage{grid}}
\newcommand{\gridExtra}{\Rpackage{gridExtra}}
\newcommand{\qplot}{\Rfunction{qplot}}
\newcommand{\autoplot}{\Rfunction{autoplot}}

\title{Tracks: a conventient binding/alignment tool for plots}
\author{Tengfei Yin}
\date{\today}


\begin{document}
\setkeys{Gin}{width=0.6\textwidth}
\maketitle
\tableofcontents

\section{Motivation}
Track-based view are widely used in almost all genome viewers, it usually stacks
multiple plots row by row and align them on exactly the same coordinate, which
in most cases, the genomic coordinates. In this way, we could be able to align
various annotation data against each other to make an efficient comparison. UCSC
genome browser\footnote{http://genome.ucsc.edu/cgi-bin/hgGateway} is one of the
most widely used track-based genome browser, as shown in Figure
\ref{fig:ucsc}. There are some other packages in \R{}, that support track-based
view like UCSC genome browser, such as \Rpackage{Gviz}. \Rpackage{Gviz} produces
elegant graphics which could be an equvilent to UCSC genome browser, what's
more, it provides more flexibility to full R graphics system and could plot data
in more different ways. To conclude, general tracks for viewing genomic data
should probably have following features:

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.8\textwidth]{figures/ucsc.png}
\end{figure}


\begin{itemize}
 \item Align each plot in exactly the same X coordinate(genomic coordinate).
 \item Naming ability for each track, this is different from Y-label, which is
   used to illustrate variable used as y.
 \item Usually only keep bottom scale for X to show genomic position, or use an
   extra 'scale' track.
 \item Multiple ways to visualize the data, as points, line, bar chart or density.etc.
 \item Order of tracks could be changed.
\end{itemize}

As comparison, \ggbio{} is trying to be even more general in terms of building
tracks, and offer more features. 

\begin{itemize}
\item You can bind any graphics produced by \ggplot{}, not necessarily produced
  by \ggbio{}, in that way, \ggplot{} users will find it pretty conventient that
  they can construct plots independently, and \Rfunction{tracks} will align them
  for you. So you can use \Rfunction{tracks} to align your time series data.
\item Easy-to-use utilities for zooming, backup, restore a view. This is useful
  when you tweak around with your best snapshot, so you can always go back.
\item A extended \textbf{"+"} method. If you are familiar with \ggplot{}'s
  \textbf{"+"} method to edit an existing plot, this is the way it works, if
  tracks is \textbf{"+"} with anything behind, it will be applied to each track. This
  make it easy to tweak with theme and update all the plots.
\item Allow you to bind some tracks without aligning them, for example, if you
  want to add a single chromosome overview as it is, you don't want to
  synchronize it with others.
\end{itemize}

NOTE: \Rfunction{tracks} function only support graphic objects produced by
either \ggplot{} or \ggbio{}. Advanced users could tweak in grid level of
course.

\section{Usage}
Function \Rfunction{tracks} is a constructor for object \Robject{Tracks}. This
object is a container for each plot, and with graphic attributes controlling the
appearance of tracks.

\subsection{Create a minimal track}
Let's first simulate a set of \Robject{GRanges}, represents a set of short
reads, and a \Robject{GRangesList} represent two isoforms. Then load \ggbio{}
and create two plots for these two data sets as shown in Figure
\ref{fig:short-reads} and Figure \ref{fig:exons}.

@ 
<<gr-simul>>=
set.seed(1)
library(GenomicRanges)
## simulate short reads
gr1 <- GRanges("chr1", IRanges(start = sample(1:10, size = 50, replace = TRUE),
                               width = 4))
## simulate exons
grl <- GRangesList(GRanges("chr1", IRanges(start = c(1, 10, 20), width = 5)),
                   GRanges("chr1", IRanges(start = c(1, 20), width = 5)))
@ %def 

@ 
<<shortread-plot, echo = FALSE, fig = TRUE, include = FALSE>>=
library(ggbio)
p1 <- autoplot(gr1)
print(p1)
@ %def  

@ 
<<exons-plot, fig = TRUE, include = FALSE>>=
p2 <- autoplot(grl)
print(p2)
@ %def   

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.45\textwidth]{tracks-shortread-plot}
  \includegraphics[width = 0.45\textwidth]{tracks-exons-plot}  
  \caption{Simulated short reads and exons. The plot on the left shows a set of
    short rectangle which represents some short reads. And the plot on the
    right panel, shows two isoforms, rectangle represents exons and chevron
    represents introns.}
  \label{fig:sr-exons}
\end{figure}

We noticed their X-scale is NOT exactly the same, if you simply use
\Rfunction{grid.arrange} function to arrange them, it's not going to be aligned
as shown in Figure \ref{fig:grid_arrange}.

\begin{figure}[h!t!p]
  \centering
@ 
<<grid_arrange, fig = TRUE>>=
library(gridExtra)
grid.arrange(p1, p2)
@ %def 
  \caption{plots arranged by \Rfunction{grid.arrange}. This function only simply
  put plots row by row, it doesn't align them.}
  \label{fig:grid_arrange}
\end{figure}


Now we introduce more powerful function \Rfunction{tracks}, which align plots,
keep only bottom x-scale, and with more control over it.

\begin{figure}[!htpb]
  \centering
@ 
<<tracks-sr-ex, fig = TRUE>>=
tracks(p1, p2)
@ %def   
\caption{Simply binding two plots. Top track shows simulated short reads and
  bottom track shows simulated exons. Without specifying heights for each track,
  they automatically have equal heights.}
  \label{fig:tracks-simple}
\end{figure}


Let's make it look more elegant, since the exons track only take one row, we
better use different heights for each track, and what's more, we may want to
naming each track. To name each track, you can simply pass graphic object with
names or put them in a list().
\begin{itemize}
\item You can pass as many plots as you want in \Rfunction{tracks}, just make
  sure you put them in the beginning. To name each track, you can either add
  quoted name before each graphic object, or pass a named list of graphic
  object. Not all of them need to be named, the one without names will create a
  blank label without text.
\item \Rfunarg{heights} argument accept a numeric vector to specify height
  proportion for each passed plot.
\end{itemize}

\begin{figure}[!htpb]
  \centering
@ 
<<tracks-sr-ex-more, fig = TRUE>>=
tracks("Short Reads" = p1, "Exons" = p2, heights = c(3, 1))
## this is equivalent to 
## tracks(list("Short Reads" = p1, "Exons" = p2))
@ %def   
  \caption{Simply biding two plots by function \Rfunction{tracks}, top track
    shows simulated short reads and bottom track shows simulated exons. Strip on
  the left labeled by names for each track.}
  \label{fig:tracks-simple}
\end{figure}

We can customize the tracks even more ourselves.
\begin{itemize}
\item \Rfunarg{label.text.cex}: track name size.
\item \Rfunarg{label.text.color}: track label background color.
\item \Rfunarg{label.bg.color}: track label background fill color.
\item \Rfunarg{track.plot.color}: track background color.
\item \Rfunarg{label.width}: track label width.
\end{itemize}

\begin{figure}[!htpb]
  \centering
@ 
<<tracks-sr-ex-more2, fig = TRUE>>=
## to use unit(), load grid.
library(grid)
tracks("Short Reads" = p1, "Exons" = p2, heights = c(3, 1), label.text.cex = 2,
       label.text.color = "white", label.bg.fill = "brown", 
       label.width = unit(5, "line"))
@ %def   
\caption{Biding two plots with function \Rfunction{tracks}. By tweaking with
  parameters, we controlled the size/color of labels and text and background
  color for each track.}
  \label{fig:tracks-simple}
\end{figure}


\newpage
\subsection{Add-on edit and utilities for \Robject{Tracks} object}
\subsubsection{``+'' method}
Now we introduce the ``+'' method, we can save the object tracks() returned, and
modify it later by plussing modification components later. 

In the following example, we remove all labels and background, result is shown
in Figure \ref{fig:plusall}.

\begin{figure}[!htpb]
  \centering
@ 
<<plus, fig = TRUE>>=
## change track plot background color
p.track <- tracks("Short Reads" = p1, "Exons" = p2, heights = c(4, 1), 
           label.text.color = "white", label.bg.fill = "brown",
           track.plot.color = c("white", "#FFFEDB"))
## apply theme_null() to all track
p.track + theme_null()
@ %def   
  \caption{An example applied modification to all tracks by using "+", removing
    all labels and background grid}
  \label{fig:plusall}
\end{figure}


Maybe next question is what if you only want to control and update one plot,
since we store all the graphic objects in slot \textbf{grobs} (a list of graphic
object)in
\Robject{Tracks} object, you could simply modify specify ones.

\begin{figure}[!htpb]
  \centering
  @ 
<<specific-plus, fig = TRUE>>=
## only apply change to one track
p.track@grobs[[1]] <- p.track@grobs[[1]] + theme_null()
p.track
@ %def 
  \caption{An example applied modification to only the first track by using "+", removing
    all labels and background grid}
  \label{fig:plus_one}
\end{figure}


\subsubsection{Zoom in/out}
If you are a \ggplot{} user, The first thing came to mind maybe use
function \Rfunction{xlim} and \Rfunction{coord\_cartesian} in the end. Keep in mind here
are the difference for both function in \ggplot{}:

\begin{itemize}

\item \Rcode{+xlim()}: remove data which out of range and re-plot it. 
\item \Rcode{+coord\_cartesian()}: That is usually what we want to for zoom, like you are
  looking at it with a magnifying glass. This function won't remove any of the
  original data, it's just update the ``view''. 
\item \Rfunarg{xlim} argument in \Rfunction{tracks} function. This does the same
  thing as \Rfunction{coord\_cartesian}.
\item \Rfunarg{xlim(obj)<- new\_range} method. This does the same thing as
  \Rfunction{coord\_cartesian}, but you meed to print or show it to see the
  effect. This process won't affect current view.
\item \Rcode{update(obj, xlim = new\_range)} method. This does the same thing as
  \Rfunction{coord\_cartesian}. \textit{new\_range} here could be a numeric
  vector of length 2, or a \Robject{IRanges}, or a \Robject{GRanges} object. If
  a graphic device is open, you can see the effect, immediately
\end{itemize}


@ 
<<zoom-in, fig = FALSE, eval = FALSE >>=
p.track <- tracks("Short Reads" = p1, "Exons" = p2, heights = c(4, 1)) 

## remove data outside c(1, 6)
p.track + xlim(c(1, 6))

## keep original data, simply zooming to [1, 10]
p.track + coord_cartesian(xlim = c(1, 10))

## more easy with ggbio's 'xlim<-', you need to print it to see the effect.
xlim(p.track) <- c(1, 6)
p.track

## or update, if a graphic device is open, you can see the effect, immediately. 
update(p.track, xlim = c(1, 4))
@ %def 

\subsubsection{Backup and reset}
Users may find it very useful, if they can backup current view with current
graphical settings, then will feel more comfortable to tweak further with range
and find position of interests or even best snapshot, you can always save it to
your disk, but to save time, a simple backup/reset process can help you
achieve that purpose.
\begin{itemize}
\item backup: backup current view and settings for all tracks.
\item reset: restore tracks to what's backed up, if no backup process taken,
  will reset to original plots when creation of tracks.
\end{itemize}

@ 
<<backup-and-reset, fig = FALSE>>=
p.track
xlim(p.track) <- c(1, 4)
p.track
## back it up
p.track <- backup(p.track)
## change to another view
xlim(p.track) <- c(1, 10)
p.track
reset(p.track)
@ %def 

\subsubsection{Bind plots produced by \ggplot{}}
As mentioned before, we can always align other plots produced by just \ggplot{},
if you are familiar with that package, and wanyt to construct graphics yourself
instead of using \ggbio{}, it's always possible. 

\begin{figure}[!htpb]
  \centering
@ 
<<ggplot, fig = TRUE>>=
p.gg <- qplot(x = seq(from = 1, to = 20, length.out = 500), y = rnorm(500), geom = "area")
p.track <- tracks("density" = p.gg, "Short Reads" = p1, "Exons" = p2, heights = c(2, 5, 1))
p.track
@ %def 
  \caption{Adding \ggplot{} produced plots directly to tracks.}
  \label{fig:gg}
\end{figure}

Even faceting for the single track won't affect the general alignments as shown
in Figure \ref{fig:facet}.
\begin{itemize}
\item Currently only faceted by rows is supported, faceted by column might get
  complicated which cannot guarantee an accurate alignment.
\item Faceting label won't affect the alignments.
\end{itemize}

\begin{figure}[!htpb]
  \centering
@ 
<<ggplot-facet, fig = TRUE>>=
p.gg <- qplot(data = mtcars, x = mpg, y = wt, facets = cyl ~.)
p.track <- tracks("Random" = p.gg, "Short Reads" = p1, "Exons" = p2, heights = c(4, 5, 2))
p.track
@ %def   
  \caption{An example showing faceting of single track won't affect overall
    alignment. The top track just use a default data set called mtcars, this
    demonstrates users need to make sure the plots they are aligning have same x
  scale definition because tracks function simply does its job align everything
  passed.}
  \label{fig:facet}
\end{figure}


\section{Recommended reading}
You could also check another vignette, which is a case study, ``CHiP-seq
visualization'', in that tutorial, we have constructed a fairly more
complicated genomic tracks.

Another useful source is \ggplot{}'s on-line documentation and examples, because
most post-plot modification is compatible with \ggbio{} object or
\Robject{Tracks} object.

\section{sessionInfo}
@ 
<<session-info>>=
sessionInfo()
@ %def 

\end{document}
