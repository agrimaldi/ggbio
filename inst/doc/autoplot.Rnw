%\VignetteIndexEntry{Autoplot: A high level function for 'smart' object-oriented visualization.}
%\VignetteDepends{}
%\VignetteKeywords{visualization utilities}
%\VignettePackage{ggbio}
\documentclass[10pt]{article}

% \usepackage{times}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}

% \SweaveOpts{width = 2.5, height = 2}


\textwidth=6.5in
\textheight=8.5in
\parskip=.3cm
\parindent = 0cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in



\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioc}{\software{Bioconductor}}
\newcommand{\IRanges}{\Rpackage{IRanges}}
\newcommand{\biovizBase}{\Rpackage{biovizBase}}
\newcommand{\ggbio}{\Rpackage{ggbio}}
\newcommand{\visnab}{\Rpackage{visnab}}
\newcommand{\ggplot}{\Rpackage{ggplot2}}
\newcommand{\grid}{\Rpackage{grid}}
\newcommand{\gridExtra}{\Rpackage{gridExtra}}
\newcommand{\qplot}{\Rfunction{qplot}}
\newcommand{\autoplot}{\Rfunction{autoplot}}

\title{Autoplot: A high level function for 'smart' object-oriented visualization.}
\author{Tengfei Yin}
\date{\today}

\setkeys{Gin}{width=0.75\textwidth}
\begin{document}
\maketitle
\tableofcontents
\section{API}
API about is \autoplot{} is kind of like a wrapper around the grammar. If you are
familiar with API of \ggplot{}, it's very similar. 


\begin{verbatim}
autoplot(object = , geom = , stat = , coord = , facets = , scale = , ...)
\end{verbatim}

Most time only \Rfunarg{object} parameters are required, and we have default for
all other components, \ggbio{} have default for each object trying to make smart
guess for user's purpose for particular data. \Rfunarg{...} means for particular
data we accept or sometimes require extra arguments to control the graphics. For
example, in some cases, like for a \Robject{TranscriptDb} object, user has to
pass a \Rfunarg{which} argument to tell \ggbio{} which region you want to
visualize, not the entire genome which make no sense here. 

\section{Usage}
\subsection{autoplot,GRanges}\label{sec:gr}
\autoplot{} for \Robject{GRanges} object is designed to be most general plot API
in \ggbio{} package. \Robject{GRanges} is most suitable data structure for
storing interval data with medata data, which could be used for representing a
set of short reads or genomic features.

Supported geom designed specifically for \Robject{GRanges}, including "rect",
"chevron", "alignment", "arrowrect", "arrow", "segment", "arch", and special
statistical transformation contains "identity", "coverage", "stepping",
"aggregate", "table", "gene", "mismatch". And they are implemented in lower API,
such as \Rfunction{geom\_alignment} and \Rfunction{stat\_coverage}. If you pass
other 'geom'and 'stat' other than those ones, it first use 'fortify' method in
\ggbio{} to coerce a \Robject{GRanges} into a 'data.frame' object. And a new
variable 'midpoint' is created and added to final 'data.frame' to be used to
mapped as 'x'. So you can use it as other \ggplot{} API.

Inside, \autoplot{} will choose the best choice for your combination of 'geom'
and 'stat'.

For aesthetics mapping now, users have to pass them to \Rfunction{aes()}
functions and pass it into \autoplot{}, for example
    
\Rcode{autoplot(data, color = score)}
	
won't work, you have to use 

\Rcode{autoplot(data, aes(color = score))}
	
Load packages
@ 
<<load>>=
library(ggbio)
@ %def 

Let's generate some simulated interval data and store it as \Robject{GRanges} object.

@ 
<<simul>>=
set.seed(1)
N <- 1000
library(GenomicRanges)
gr <- GRanges(seqnames = 
              sample(c("chr1", "chr2", "chr3"),
                     size = N, replace = TRUE),
              IRanges(
                      start = sample(1:300, size = N, replace = TRUE),
                      width = sample(70:75, size = N,replace = TRUE)),
              strand = sample(c("+", "-", "*"), size = N, 
                replace = TRUE),
              value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              sample = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))

idx <- sample(1:length(gr), size = 50)
@ %def 
\clearpage

Let's first take a look at a general table about stat/geom/layout/coord/scale,
\autoplot{} for \Robject{GRanges} supported, this table is just a subset and
will keep completing with more.

\begin{table}[h!t!b!p]
\begin{center}
\small{
\begin{tabular}{|p{1.4cm}|p{3cm}|p{8cm}|p{0.6cm}|}
\hline
Comp & name  & usage & icon\\\hline
\textbf{geom} &geom\_rect & rectangle& \includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_rect.pdf}\\
              &geom\_segment & segment& \includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_segment.pdf}\\
              &geom\_chevron & chevron&\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_chevron.pdf}\\
              &geom\_arrow & arrow&\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_arrow.pdf}\\
              &geom\_arch & arches &\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_arch.pdf}\\
              &geom\_bar & bar &\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_bar.pdf}\\
              &geom\_alignment & alignment (gene) & 
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_alignment.pdf}\\\hline
\textbf{stat} 
              &stat\_coverage & coverage (of reads) &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_coverage_icon.pdf}\\
              &stat\_mismatch & mismatch pileup for alignments &
              \includegraphics[height = 0.25cm,width = 0.6cm]{figures/stat_mismatch.pdf}\\
              &stat\_aggregate & aggregate in sliding window &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_aggregate.pdf}\\
              &stat\_stepping & avoid overplotting &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_stepping.pdf}\\
              &stat\_gene & consider gene structure &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_gene.pdf}\\
              &stat\_table & tabulate ranges &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_table.pdf}\\
              &stat\_identity & no change &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_identity.pdf}\\\hline
\textbf{coord} &linear& ggplot2 linear but facet by chromosome &
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_linear.pdf}\\
               &genome& put everything on genomic coordinates&
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_genome.pdf}\\
               &truncate gaps & compact view by shrinking gaps&
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_truncate_gaps.pdf}\\\hline
\textbf{layout}& track & stacked tracks &\includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_linear.pdf}\\
              &karyogram & karyogram display &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/layout_karyogram.pdf}\\
              &circle & circular &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/layout_circle.pdf}\\\hline
\textbf{faceting}&formula & facet by formula &
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/facet.pdf}\\
                 &ranges & facet by ranges &
                 \includegraphics[height = 0.25cm, width = 0.6cm]{figures/facet_gr.pdf}\\\hline
\textbf{scale} &not extended  & \ggplot{}default& \\\hline
\end{tabular}
}
\end{center}
\caption{Components of the basic grammar of graphics, with the extensions available in 
\ggbio{}.}
\label{tab:components}
\end{table}

\clearpage
Default is to use geom "rect" to represent those 'short reads', show overlaped
intervals on different levels to help visualize the data.
\begin{figure}[!htpb]
  \centering
@ 
<<default, fig = TRUE>>=
autoplot(gr[idx])
@ %def  
  \caption{gr-default}
  \label{fig:gr-default}
\end{figure}
\clearpage

Geom 'bar'just show intervals' region as they are and use a sepcified y in
\Rfunction{aes()} to show as the height of bars, default is to use 'score' in
the data if exists, because in most genomic data format, such as BED format, the
score are reserved column.
@ 
<<bar-default-pre>>=
set.seed(123)
gr.b <- GRanges(seqnames = "chr1", IRanges(start = seq(1, 100, by = 10),
                  width = sample(4:9, size = 10, replace = TRUE)),
                score = rnorm(10, 10, 3), value = runif(10, 1, 100))
gr.b2 <- GRanges(seqnames = "chr2", IRanges(start = seq(1, 100, by = 10),
                  width = sample(4:9, size = 10, replace = TRUE)),
                score = rnorm(10, 10, 3), value = runif(10, 1, 100))
gr.b <- c(gr.b, gr.b2)
head(gr.b)
@ %def 

\begin{figure}[!htpb]
  \centering
@ 
<<bar-default, fig = TRUE>>=
p1 <- autoplot(gr.b, geom = "bar")
## use value to fill the bar
p2 <- autoplot(gr.b, geom = "bar", aes(fill = value))
tracks(default = p1, fill = p2)
@ %def   
  \caption{Bar geom for GRanges.}
  \label{fig:gr-bar}
\end{figure}
\clearpage

Facetting, some combination of geom/stat

@ 
<<fig = TRUE>>=
autoplot(gr[idx], geom = "arch", aes(color = value), facets = sample ~ seqnames)
@ %def 
\clearpage
Group need to be specified in \Rfunction{aes()} use aesthetics \Rfunarg{group},
this help to assign grouped intervals showing on the same y level, especially ,
when you use \Rfunarg{geom} 'alignment', gaps will be created based on group
information and shown on the plot. A minimal example is shown in the following
chunks.  
\begin{figure}[!htpb]
  \centering
@ 
<<gr-group, fig = TRUE>>=
gra <- GRanges("chr1", IRanges(c(1,7,20), end = c(4,9,30)), group = c("a", "a", "b"))
## if you desn't specify group, then group based on stepping levels, and gaps are computed without
## considering extra group method
p1 <- autoplot(gra, aes(fill = group), geom = "alignment")
## when use group method, gaps only computed for grouped intervals.
## default is group.selfish = TRUE, each group keep one row.
## in this way, group labels could be shown as y axis.
p2 <- autoplot(gra, aes(fill = group, group = group), geom = "alignment")
## group.selfish = FALSE, save space
p3 <- autoplot(gra, aes(fill = group, group = group), geom = "alignment", group.selfish = FALSE)
tracks('non-group' = p1,'group.selfish = TRUE' = p2 , 'group.selfish = FALSE' = p3)
@ %def   
  \caption{Grouping method comparison for geom alignment.}
  \label{fig:gr-group}
\end{figure}
\clearpage
Faceted by strand help you understand coverage from different sequencing direction. 
\begin{figure}[!htpb]
  \centering
@ 
<<gr-facet-strand, fig = TRUE>>=
autoplot(gr, stat = "coverage", geom = "area", 
         facets = strand ~ seqnames, aes(fill = strand))
@ %def   
  \caption{Facet by strand to show coverage.}
  \label{fig:facet-strand}
\end{figure}
\clearpage
New coordinate transformation 'genome' will transform a \Robject{GRanges} object
into a genome space, align them up based on 'seqlevel' orders. This
transformation allows you to add 'seqlengths' to your \Robject{GRanges} object
to produce a fixed width. and add buffer in between by specifying
\Rfunarg{space.skip}. This transformation is useful for grand linear view as
Manhattan plot or circular view. 

Please read another two vignette about how to plot Manhattan plot and generate
circular view for detail.
\begin{figure}[!htpb]
  \centering
@ 
<<gr-autoplot-circle, fig = TRUE>>=
autoplot(gr[idx], layout = 'circle') 
@ %def   
  \caption{minimal example for circular transformation.}
  \label{fig:gr-circle}
\end{figure}
\clearpage

A little more 
\begin{figure}[!htpb]
  \centering
@ 
<<gr-circle, fig = TRUE>>=
seqlengths(gr) <- c(400, 500, 700)
values(gr)$to.gr <- gr[sample(1:length(gr), size = length(gr))]
idx <- sample(1:length(gr), size = 50)
gr <- gr[idx]
ggplot() + layout_circle(gr, geom = "ideo", fill = "gray70", radius = 7, trackWidth = 3) +
  layout_circle(gr, geom = "bar", radius = 10, trackWidth = 4, 
                aes(fill = score, y = score)) +
  layout_circle(gr, geom = "point", color = "red", radius = 14,
                trackWidth = 3, grid = TRUE, aes(y = score)) +
  layout_circle(gr, geom = "link", linked.to = "to.gr", radius = 6, trackWidth = 1)
@ %def 
  \caption{Circular layout minimal example.}
  \label{fig:gr-circle}
\end{figure}
\clearpage

You will find a more general tutorial for circular view in another vignette
distributed with this package.

\subsection{autoplot,Seqinfo}
When a \Robject{GRanges} has seqlengths information which defined chromomsome
lengths, we have a way to quickly give a karyogram overview for adding data on
later. Please read another vignette about karyogram overview. 

You can easily subset/re-order the visualized the chromosomes by using '[' method.
@ 
<<seqinfo-src>>=
data(hg19Ideogram, package = "biovizBase")
sq <- seqinfo(hg19Ideogram)
sq
@ %def 
\clearpage
\begin{figure}[!htpb]
  \centering
@ 
<<seqinfo, fig = TRUE>>=
autoplot(sq[paste0("chr", c(1:22, "X"))])
@ %def   
  \caption{Seqinfo visualization for chromosomes 1 to 22 and X.}
  \label{fig:seqinfo}
\end{figure}

\clearpage

\subsection{autoplot,IRanges}
\Rfunction{autoplot} for \Robject{IRanges} is used to visualize simple interval
data with element data together.

Supported geom designed specifically for \Robject{IRanges}, including "rect",
"chevron", "alignment", "arrowrect", "arrow", "segment", "arch", and special
statistical transformation contains "identity", "coverage", "stepping",
"aggregate", "table", "gene", "mismatch". And they are implemented in lower API,
such as \Rfunction{geom\_alignment} and \Rfunction{stat\_coverage}. If you pass
other \Rfunarg{geom} and \Rfunarg{stat} other than those ones, it first coerces
a \Robject{IRanges} into a \Robject{data.frame} object together with extra
element meta data, and added to \Robject{data.frame}.


Inside, \Robject{autoplot} will choose the best choice for your combination of
\Rfunarg{geom} and \Rfunarg{stat}.

For aesthetics mapping now, users have to pass them to \Rfunction{aes()} functions and
pass it into autoplot, for example\\
    
\Rcode{	autoplot(data, color = score)}
	
won't work, you have to use 

\Rcode{ autoplot(data, aes(color = score))}
	
for now.	

Let's generate some simulated interval data and store it as *IRanges*
object. and add some element meta data.
@ 
<<ir-load>>=
set.seed(1)
N <- 100
ir <-  IRanges(start = sample(1:300, size = N, replace = TRUE),
               width = sample(70:75, size = N,replace = TRUE))
## add meta data 
df <- DataFrame(value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              sample = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))
values(ir) <- df
ir
@ %def 
\clearpage
\autoplot{} will coerce \Robject{IRanges} together with its element meta data, so
aesthetics mapping works for those extra information too.
\begin{figure}[!htbp]
  \centering
@ 
<<ir-exp, fig = TRUE>>=
p1 <- autoplot(ir)
p2 <- autoplot(ir, aes(fill = pair)) + opts(legend.position = "none")
p3 <- autoplot(ir, stat = "coverage", geom = "line", facets = sample ~. )
p4 <- autoplot(ir, stat = "reduce")
tracks(p1, p2, p3, p4)
@ %def   
  \caption{IRanges visualization.}
  \label{fig:ir-v}
\end{figure}
\clearpage

\subsection{autoplot,GRangesList}
\Robject{GRangesList} is most suitable data structure for storing a set of genomic
 features, for example, exons/utrs in a gene. `autoplot` is designed to consider
 the native grouping information in this structure and automatically showing
 gaps within group in `geom` *alignment* and make sure grouped items are shown
 together on the same level with nothing falling in between.

 Argument \Rfunarg{main.geom} and \Rfunarg{gap.geom} control geometry for
 entities and gaps computed for them. \Rfunarg{group.selfish} help you put
 grouped items in unique y levels and show the y labels for group names.

Let's create a \Robject{GRangesList} object by splitting a \Robject{GRanges} object.
@ 
<<grl-simul>>=
set.seed(1)
N <- 100
## ======================================================================
##  simmulated GRanges
## ======================================================================
gr <- GRanges(seqnames = 
              sample(c("chr1", "chr2", "chr3"),
                     size = N, replace = TRUE),
              IRanges(
                      start = sample(1:300, size = N, replace = TRUE),
                      width = sample(30:40, size = N,replace = TRUE)),
              strand = sample(c("+", "-", "*"), size = N, 
                replace = TRUE),
              value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              sample = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))


grl <- split(gr, values(gr)$pair)
@ %def 
\clearpage
For \Robject{GRangesList} object, default is coerce it to \Robject{GRanges} and
adding extra column to preserve the grouping information. main geoms and gaps
geom are separately controlled.  
\begin{figure}[!htpb]
  \centering
@ 
<<grl-exp, fig = TRUE>>=
## default gap.geom is 'chevron'
p1 <- autoplot(grl, group.selfish = TRUE)
p2 <- autoplot(grl, group.selfish = TRUE, main.geom = "arrowrect", gap.geom = "segment")
tracks(p1, p2)
@ %def   
  \caption{Some examples showing GRangesList}
  \label{fig:grl-exp}
\end{figure}
\clearpage

Internal variable \Rfunarg{grl\_name} added to keep a track for grouping
information, you could use it for faceting or other aesthetic mapping, the
variables could be renamed by \Rfunarg{indName} argument in \autoplot{}, you
could pass either \Rcode{..grl\_name..} or \Rcode{grl\_name} in the mapping, I
prefer the first one, it tells that it's interval variables.  
\begin{figure}[!htpb]
  \centering
@ 
<<grl-name, fig = TRUE>>=
autoplot(grl, aes(fill = ..grl_name..))
## equal to 
## autoplot(grl, aes(fill = grl_name))
@ %def   
  \caption{Tweak with name.}
  \label{fig:grl-name}
\end{figure}
\clearpage

\subsection{autoplot,Rle}
\Robject{Rle} is a general container for storing atomic vector which is defined
in package \Robject{IRanges}, data is stored in a run-length encoding format.

For \Robject{Rle}, we bring following method, three stat, two geom and four types.

Two geom
\begin{itemize}
\item \textbf{bar}: default, controlled by 'nbin'.
\item \textbf{heatmap}: show Rle as heatmap, use color to indicate values,
  controlled by 'nbin'.
\end{itemize}

Three default statistical transformation
\begin{itemize}
\item \textbf{bin}: bin the object, default is 30 bins in the view, controlled
  by argument \Rfunarg{nbin}. Then in each bin make summary against specified
  types.
\item \textbf{identity}: transform data to raw vector, then you can use many
  other geom such as line or point. Default x and y is internally set to
  position and value.
\item \textbf{slice}: use \Rfunarg{lower} to slice the object to islands, then
  use bar or heatmap to represent the island.
\end{itemize}

Four types for compute the statistical summary.
\begin{itemize}
\item \textbf{viewSums}: sums in the sliced view or bins.
\item \textbf{viewMins}: min values in the sliced view or bins.
\item \textbf{viewMaxs}: max values in the sliced view or bins.  
\item \textbf{viewMeans}: mean values in the sliced view or bins.    
\end{itemize}

Let's simulate some data first.
@ 
<<rle-simul>>=
library(IRanges)
library(ggbio)
set.seed(1)
lambda <- c(rep(0.001, 4500), seq(0.001, 10, length = 500), 
            seq(10, 0.001, length = 500))

## @knitr create
xVector <- rpois(1e4, lambda)
xRle <- Rle(xVector)
xRle
@ %def 
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<rle-bin, fig = TRUE>>=
p1 <- autoplot(xRle)
p2 <- autoplot(xRle, nbin = 80)
p3 <- autoplot(xRle, geom = "heatmap", nbin = 200)
tracks('nbin = 30' = p1, "nbin = 80" = p2, "nbin = 200(heatmap)" = p3)
@ %def 
  \caption{Compare different geom and nbin by using default bin stat.}
  \label{fig:rle-bin}
\end{figure}
\clearpage


\begin{figure}[!htpb]
  \centering
@ 
<<rle-id, fig = TRUE>>=
p1 <- autoplot(xRle, stat = "identity")
p2 <- autoplot(xRle, stat = "identity", geom = "point", color = "red")
tracks('line' = p1, "point" = p2)
@ %def 
  \caption{Compare different geom and nbin by using stat identity.}
  \label{fig:rle-id}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<rle-slice, fig = TRUE>>=
p1 <- autoplot(xRle, type = "viewMaxs", stat = "slice", lower = 5)
p2 <- autoplot(xRle, type = "viewMaxs", stat = "slice", lower = 5, geom = "heatmap")
tracks('bar' = p1, "heatmap" = p2)
@ %def 
  \caption{Compare different geom and nbin by using stat slice.}
  \label{fig:rle-slice}
\end{figure}
\clearpage




\subsection{autoplot,RleList}
All methods are the same for \Robject{RleList} as for \Robject{Rle}, it's just
faceted by listed group automatically. Please read the autoplot,Rle section first.

Let's simulate some data first.
@ 
<<rlel-simul>>=
xRleList <- RleList(xRle, 2L * xRle)
xRleList
@ %def 
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<rlel-bin, fig = TRUE>>=
p1 <- autoplot(xRleList)
p2 <- autoplot(xRleList, nbin = 80)
p3 <- autoplot(xRleList, geom = "heatmap", nbin = 200)
tracks('nbin = 30' = p1, "nbin = 80" = p2, "nbin = 200(heatmap)" = p3)
@ %def 
  \caption{Compare different geom and nbin by using default bin stat.}
  \label{fig:rlel-bin}
\end{figure}
\clearpage

 
\begin{figure}[!htpb]
  \centering
@ 
<<rlel-id, fig = TRUE>>=
p1 <- autoplot(xRleList, stat = "identity")
p2 <- autoplot(xRleList, stat = "identity", geom = "point", color = "red")
tracks('line' = p1, "point" = p2)
@ %def 
  \caption{Compare different geom and nbin by using stat identity.}
  \label{fig:rlel-id}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<rlel-slice, fig = TRUE>>=
p1 <- autoplot(xRleList, type = "viewMaxs", stat = "slice", lower = 5)
p2 <- autoplot(xRleList, type = "viewMaxs", stat = "slice", lower = 5, geom = "heatmap")
tracks('bar' = p1, "heatmap" = p2)
@ %def 
  \caption{Compare different geom and nbin by using stat slice.}
  \label{fig:rlel-slice}
\end{figure}
\clearpage

\subsection{autoplot,TranscriptDb}
Please read another vignette called \textit{How to plot genomic features by
  using \Robject{TranscriptDb} object}

Some simple demonstration:
@ 
<<txdb>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
data(genesymbol, package = "biovizBase")
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
@ %def 

\clearpage \Rfunarg{which} argument accept a \Robject{GRanges, list} which is
\textbf{required} to subset the data. \Rfunarg{names.expr} accept string pattern
or expression to parse the y tick labels. Otherwise it's not going to show all
of them. We are trying to show the ALDOA gene in the following example.
\begin{figure}[!htpb]
  \centering
@ 
<<txdb-visual, fig = TRUE>>=
p1 <- autoplot(txdb, which = genesymbol["ALDOA"], names.expr = "tx_name:::gene_id")
p2 <- autoplot(txdb, which = genesymbol["ALDOA"], stat = "reduce", color = "brown", 
               fill = "brown")
tracks(full = p1, reduce = p2, heights = c(5, 1)) + ylab("")
@ %def   
\caption{TranscriptDb visualziation. Top track shows all the transcripts while
  bottom track reduce them and show a single track.}
  \label{fig:txdb-v}
\end{figure}

\subsection{autoplot,GappedAlignment}\label{sec:gapped}
The \Robject{GappedAlignments} class is a container to store a set of
alignments, which is defined in package \Rpackage{GenomicRanges}. 

Let's load some data.
@ 
<<ga-load>>=
library(Rsamtools)
data("genesymbol", package = "biovizBase")
bamfile <- system.file("extdata", "SRR027894subRBM17.bam", package="biovizBase")
## need to set use.names = TRUE
ga <- readBamGappedAlignments(bamfile,
                              param = ScanBamParam(which = genesymbol["RBM17"]),
                              use.names = TRUE)
@ %def 
\clearpage
Default is to show gapped line, we also could show them as simple short reads
and coverage.
\begin{figure}[!htpb]
  \centering
@ 
<<ga-exp, fig = TRUE>>=
p1 <- autoplot(ga)
p2 <- autoplot(ga, geom = "rect")
p3 <- autoplot(ga, geom = "line", stat = "coverage")
tracks(default = p1, rect = p2, coverage = p3)
@ %def   
  \caption{Visualization of GappedAlignemnt object}
  \label{fig:ga-v}
\end{figure}

\subsection{autoplot,BamFile}\label{sec:bamfile}
For \Robject{BamFile}, we bring a fast estimated method(implemented by Michael
Lawrence), which is suitable for overview for particular chromosome and a much
slower raw data view which could be used in visualizing a small region.

Load some raw data first, we didn't provide an attached data here, you can try
to download a whole genome NGS seq file fro ENCODE or somewhere else.
@ 
<<bf-load, eval = FALSE>>=
library(Rsamtools)
bamfile <- "./wgEncodeCaltechRnaSeqK562R1x75dAlignsRep1V2.bam"
bf <- BamFile(bamfile)
@ %def 

A very efficient method called 'estimate', \Rfunarg{which} argument accepted a
chromsome names, will give you an overview about coverage. If multiple
chromosome names are provided, it will be faceted by seqnames. If which is
missing, it's going to use the first chromosomes appeared in the header.

@ 
<<bf-est-cov, eval = FALSE>>=
autoplot(bamfile)
autoplot(bamfile, which = c("chr1", "chr2"))
autoplot(bf)
autoplot(bf, which = c("chr1", "chr2"))

data(genesymbol, package = "biovizBase")
autoplot(bamfile,  method = "raw", which = genesymbol["ALDOA"])

library(BSgenome.Hsapiens.UCSC.hg19)
autoplot(bf, stat = "mismatch", which = genesymbol["ALDOA"], bsgenome = Hsapiens)
@ %def 


\subsection{autoplot,character}
When the object is character it accept a file with extensions \textit{.bam } or
any other extension names package \Rpackage{rtracklayer} supported, such as
\textit{.bed, .gif}. If the object could be imported by \Rpackage{rtracklayer},
it will be turned into a \Robject{GRanges} object, and 'score' column will be
potentially used.  So please read Section \ref{sec:gr} Section
\ref{sec:gapped} Section \ref{sec:bamfile} for related topics. 

For example, if you have a bam file
@ 
<<char-bam, eval = FALSE>>=
bamfile <- "./wgEncodeCaltechRnaSeqK562R1x75dAlignsRep1V2.bam"
autoplot(bamfile)
@ %def 

Or for an example bed file, remember you can pass an argument \Rfunarg{which} to
subset the data.
\begin{figure}[!htpb]
  \centering
@ 
<<char-gr, fig = TRUE>>=
library(rtracklayer)
test_path <- system.file("tests", package = "rtracklayer")
test_bed <- file.path(test_path, "test.bed")
autoplot(test_bed, aes(fill = name))
@ %def   
  \caption{autoplot for bed files}
  \label{fig:char-bed}
\end{figure}

\subsection{autoplot,matrix}
For object \Robject{matrix}, the default graphic would be heatmap, here we bring
more controls over it.
\begin{itemize}
\item Argument \Rfunarg{genomic.pos} controls whether you want to show heatmap
  on genomic scale, which means, if set to \Rcode{TRUE}, this means the column
  name of matrix would be genomic position, so the heatmap is going to be
  distributed along genome and filled with blank cell. If weird things happens
  when the space is huge, some information may be lost(this have not been fixed
  yet), so a 'compact' version(default) will be recommended, unless you want to
  bind this track with other tracks by using \Rfunction{tracks} function. 
\item Function \Rfunction{scale\_fill\_fold\_change}(not default) will scale the heatmap due to
  a classic blue-white-red color scheme, where 0 is set to white color, negative
  value set to blue and positive value set to red.
\end{itemize}

This underlies fundamental heatmap for other object such as
\Robject{ExpressionSet, SummarizedExperiment, VCF}, which we will introduce
later.

We use \Robject{volcano} default data as an example, it's not a real microarray
data, just demonstrate how to visualize a \Robject{matrix}.
\begin{figure}[!htpb]
  \centering
@ 
<<matrix-default, fig = TRUE>>=
autoplot(volcano)
@ %def   
  \caption{Default graphic for matrix object is heatmap.}
  \label{fig:matrix-default}
\end{figure}
\clearpage

In biological papers, a blue-white-scale is commonly used for making heatmap.
\begin{figure}[!htpb]
  \centering
@ 
<<matrix-default-scale, fig = TRUE>>=
autoplot(volcano-150)+scale_fill_fold_change()
@ %def   
  \caption{Default graphic for matrix object is heatmap. We scale them to
    blue-white-red color scheme.}
  \label{fig:matrix-default-scale}
\end{figure}
\clearpage

Use column names to indicate genome position. 
\begin{figure}[!htpb]
  \centering
@ 
<<matrix-default-gene, fig = TRUE>>=
colnames(volcano) <- sort(sample(1:300, size = ncol(volcano), replace = FALSE))
autoplot(volcano-150, genomic.pos = TRUE)+scale_fill_fold_change()
@ %def   
  \caption{Default graphic for matrix object is heatmap, we plot matrix to a
    genomic position based on assumption that column names are genomic
    positions. }
  \label{fig:matrix-default-gene}
\end{figure}
\clearpage
\subsection{autoplot, ExpressionSet}
\Robject{ExpressionSet} object is commonly used container for storing
high-throughput assays and experimental metadata. it's defined in
\Rpackage{Biobase}.

Graphics we bring for this type of data includes:
\begin{itemize}
\item 'heatmap': default.  
\item 'pcp': parallel coordinate plots, level change for particular gene(row)
  can be easily observed cross samples.
\item 'boxplot': boxplot, summary over samples.
\item 'scatterplot.matrix' pairwised comparison across samples, a quick way to
  observe correlation.   
\item other specific experimental types may require loading other packages, such as types
  'mean-sd' and 'volcano'.
\end{itemize}

Let's have some examples.

@ 
<<>>=
library(Biobase)
data(sample.ExpressionSet)
sample.ExpressionSet
set.seed(1)
idx <- sample(seq_len(dim(sample.ExpressionSet)[1]), size = 50)
eset <- sample.ExpressionSet[idx,]
@ %def 

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default, fig = TRUE>>=
p1 <- autoplot(eset)
p1
@ %def 
  \caption{Heatmap default}
  \label{fig:eset-default}
\end{figure}
\clearpage

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default-scale, fig = TRUE>>=
p2 <- p1 + scale_fill_fold_change()
p2
@ %def 
  \caption{Heatmap default with blue-white-red scale}
  \label{fig:eset-default-scale}
\end{figure}
\clearpage

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default-pcp, fig = TRUE>>=
autoplot(eset, type = "pcp")
@ %def 
  \caption{Parallel coordinate plot.}
  \label{fig:eset-default-pcp}
\end{figure}
\clearpage

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default-boxplot, fig = TRUE>>=
autoplot(eset, type = "boxplot")
@ %def 
  \caption{Boxplot.}
  \label{fig:eset-default-boxplot}
\end{figure}
\clearpage

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default-sm, fig = TRUE>>=
autoplot(eset[, 1:7], type = "scatterplot.matrix")
@ %def 
  \caption{Scatterplot matrix.}
  \label{fig:eset-default-sm}
\end{figure}
\clearpage

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default-ms, fig = TRUE>>=
autoplot(eset, type = "mean-sd")
@ %def 
  \caption{Scatterplot matrix.}
  \label{fig:eset-default-ms}
\end{figure}
\clearpage

\begin{figure}[!htbp]
  \centering
@ 
<<eset-default-volcano, fig = TRUE>>=
autoplot(eset, type = "volcano", fac = pData(sample.ExpressionSet)$type)
@ %def 
  \caption{Scatterplot matrix.}
  \label{fig:eset-default-volcano}
\end{figure}
\clearpage

\subsection{autoplot, SummarizedExperiment}
\Robject{SummarizedExperiment} is a eSet-like container, where column represetns
samples and rows represent ranges of interest, for example, a \Robject{GRanges}
object, and it could contain one or more assays. It's defined in package
\Rpackage{GenomicRanges}. 

\begin{itemize}
\item 'heatmap': default.  
\item 'pcp': parallel coordinate plots, level change for particular gene(row)
  can be easily observed cross samples.
\item 'boxplot': boxplot, summary over samples.
\item 'scatterplot.matrix' pairwised comparison across samples, a quick way to
  observe correlation.   
\end{itemize}

@ 
<<sset>>=
nrows <- 200; ncols <- 6
counts <- matrix(runif(nrows * ncols, 1, 1e4), nrows)
rowData <- GRanges(rep(c("chr1", "chr2"), c(50, 150)),
                   IRanges(floor(runif(200, 1e5, 1e6)), width=100),
                   strand=sample(c("+", "-"), 200, TRUE))
colData <- DataFrame(Treatment=rep(c("ChIP", "Input"), 3),
                     row.names=LETTERS[1:6])
sset <- SummarizedExperiment(assays=SimpleList(counts=counts),
                             rowData=rowData, colData=colData)




@ %def 

\begin{figure}[!htpb]
  \centering
@ 
<<sset-heatmap, fig = TRUE>>=
autoplot(sset) + scale_fill_fold_change()
@ %def 
  \caption{heatmap}
  \label{fig:sset-heatmap}
\end{figure}
\clearpage


\begin{figure}[!htpb]
  \centering
@ 
<<sset-pcp, fig = TRUE>>=
autoplot(sset, type = "pcp")
@ %def 
  \caption{Parallel coordiante plot.}
  \label{fig:sset-pcp}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<sset-boxplot, fig = TRUE>>=
autoplot(sset, type = "boxplot")
@ %def 
  \caption{Boxplot.}
  \label{fig:sset-boxplot}
\end{figure}
\clearpage


\begin{figure}[!htpb]
  \centering
@ 
<<sset-sm, fig = TRUE>>=
autoplot(sset, type = "scatterplot.matrix")
@ %def 
  \caption{Scatterplot matrix}
  \label{fig:sset-sm}
\end{figure}
\clearpage


\subsection{autoplot,VCF}
\Robject{VCF}(Variant Call Format) class extends a class we have introduced
\Robject{SummarizedExperiment}, and with additional slots, 'fixed' and
'info'. It's defined in package \Rpackage{VariantAnnotation}. 

We have done some experimental visualization, and features are going to be
extended or changed later.
\begin{itemize}
\item For type 'geno': we get an assay, and test if 'GT' is in. Then we make a
  heatmap to show geno types.
\item For type 'info': Please specify one variable as y to show as bars.
\item For type 'fixed': You can plot ref/alt strings on the plot, default plot
  both reference and variants, and if one string is over 1, we will use a black
  'I' to indicate that's an indel, then if at each position there are multiple
  data, we will show them in different y levels. Argument \Rfunarg{full.string}
  control if you want to show full strings of indels or not, even they are shown
  as full string, they will still be in balck color, to indicate it's on the
  single position. \Rfunarg{ref.show} controls if you want to show REF column in
  the data or not, sometimes people may want to just plot \Robject{BSgenome}
  object as reference track.
\end{itemize}


@ 
<<vcf>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
hdr <- exptData(vcf)[["header"]]



## autoplot(vcf, type = "fixed") + coord_cartesian(xlim = c(50310860, 50310890))


@ %def 


\begin{figure}[!htpb]
  \centering
@ 
<<va-default, fig = TRUE>>=
autoplot(vcf)
@ %def 
  \caption{default heatmap to show GT for type 'geno'.}
  \label{fig:va-default}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<va-info, fig = TRUE>>=
autoplot(vcf, type = "info", aes(y  = THETA))
@ %def 
  \caption{default bar chart for type info, use THETA as y.}
  \label{fig:va-info}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<va-fixed, fig = TRUE>>=
autoplot(vcf, type = "fixed")
@ %def 
  \caption{default heatmap to show GT as heatmap for type 'fixed'.}
  \label{fig:va-fixed}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<va-fs, fig = TRUE>>=
np1 <- autoplot(vcf, type = "fixed") + xlim(50310860, 50310890) 
p2 <- autoplot(vcf, type = "fixed", full.string = TRUE) + xlim(50310860, 50310890)
tracks("full.string = FALSE" = p1, "full.string = TRUE" = p2)+
  scale_y_continuous(breaks = NULL, limits = c(0, 3))
@ %def 
  \caption{Demonstration of full.string. }
  \label{fig:va-fs}
\end{figure}
\clearpage

\begin{figure}[!htpb]
  \centering
@ 
<<va-rsw, fig = TRUE>>=
p3 <- autoplot(vcf, type = "fixed", ref.show = FALSE) + xlim(50310860, 50310890) +
    scale_y_continuous(breaks = NULL, limits = c(0, 2))
p3
@ %def 
  \caption{Demonstration of ref.show. }
  \label{fig:va-rs}
\end{figure}
\clearpage
\subsection{autoplot,BSgenome}
The \Robject{BSgenome} class is a container for the complete genome sequence of
a given organism, it's defined in package \Rpackage{BSgenome}. We use it to plot
reference genome, along with other tracks.
\begin{figure}[!htpb]
  \centering
@ 
<<bs-v, fig = TRUE>>=
library(BSgenome.Hsapiens.UCSC.hg19)
data(genesymbol, package = "biovizBase")
p1 <- autoplot(Hsapiens, which = resize(genesymbol["ALDOA"], width = 50))
p2 <- autoplot(Hsapiens, which = resize(genesymbol["ALDOA"], width = 50), geom = "rect")
tracks(text = p1, rect = p2)
@ %def   
  \caption{plot BSgenome}
  \label{fig:bs-v}
\end{figure}


\section{sessionInfo}
@ 
<<sessionInfo>>=
sessionInfo()
@ %def 

\end{document}
