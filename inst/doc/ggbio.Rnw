%\VignetteIndexEntry{ggbio: visualization for genomic data with extending the
%grammar of graphics}
%\VignetteDepends{}
%\VignetteKeywords{visualization utilities}
%\VignettePackage{ggbio}
\documentclass[10pt]{report}
% \usepackage{times}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{color}



\setkeys{Gin}{width=0.95\textwidth}

\textwidth=6.5in
\textheight=8.5in
\parskip=.3cm
\parindent = 0cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioc}{\software{Bioconductor}}
\newcommand{\IRanges}{\Rpackage{IRanges}}
\newcommand{\biovizBase}{\Rpackage{biovizBase}}
\newcommand{\ggbio}{\Rpackage{ggbio}}
\newcommand{\visnab}{\Rpackage{visnab}}
\newcommand{\ggplot}{\Rpackage{ggplot2}}
\newcommand{\grid}{\Rpackage{grid}}
\newcommand{\gridExtra}{\Rpackage{gridExtra}}
\newcommand{\qplot}{\Rfunction{qplot}}
\newcommand{\autoplot}{\Rfunction{autoplot}}
\newcommand{\knitr}{\Rpackage{knitr}}
\newcommand{\tracks}{\Rfunction{tracks}}


% my own frambox
\newcommand{\sfbox}[2][Tips]{
\begin{center}
\shadowbox{
  \parbox{0.8\linewidth}{
    \textcolor{blue}{#1:}
    #2
  }
  }
\end{center}
}

\title{\ggbio{}: visualization toolkits for genomic data}
\author{Tengfei Yin}
\date{\today}

\begin{document}
% \setkeys{Gin}{width=0.6\textwidth}
\maketitle
\newpage
\tableofcontents
\newpage

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='./figures/ggbio-', 
               fig.align='center', fig.show='asis')
options(replace.assign=TRUE,width=90)
@


<<options,echo=FALSE>>=
options(width=72)
@


\chapter{An Introduction to \ggbio{}}
\section{Citation}
<<citation>>=
citation("ggbio")
@ %def 

\section{Introduction}
A mature graphic eco-system always has a well-developed data model, a grammar
and a powerful computing platform. Grammar of graphics\footnote{``The grammar of
  graphics'' by Leland Wilkinson} is the essential part to help people
understand the underlying data by using a general visualization
framework. What's more, object-oriented graphics is especially useful for a
well-developed infrastructure system that have carefully defined data model to
store specific data sets for special purpose. Let's say, given a
\Robject{GRanges} we know it represents annotated genetic intervals, given
\Robject{TranscriptDb} we know it represents transcripts-centric annotation
data, given \Robject{matrix}, in biology, we probably expect a heatmap.

Let's scrutinize what we have in R:
\begin{itemize}
\item \textbf{data model}: \Bioc{} tries hard to define and generalize
  infrastructure for storing particular biological data. For example, we have
  \Rclass{ExpressionSet} to store microarray data, we have
  \Rclass{GappedAlignments} to store NGS alignments, and \Rclass{IRanges} to
  represent numeric intervals. This is especially useful, which make
  object-oriented programming for specific biological questions much easier, and
  make object-oriented visualization possible in \Bioc{} too. 
\item \textbf{Powerful computing platform}: \R{} is a modern statistical
  computing environment, provides plenty of models and computing method for
  multivariate data analysis, at the same time, \Bioc{} has numerous data mining
  tools in genetic analysis and other fields. These well-developed and tested
  tool kits make processing and analysis easier than before. And we have to pay
  attention to that many useful graphics are just statistical summary of raw
  data, so statistical transformation exists could be implemented as part of the
  visualization procedure.
\item \textbf{The grammar of graphics}: This conceptual framework is proposed by
  Leland Wilkinson\footnote{Please check Wilkinson's book ``The grammar of
    graphics'' for more detail.}. Hadley Wickham extended the grammar and also
  first implemented it in \R{} in his package \Rpackage{ggplot2} with great
  success. \ggbio{} is built on \ggplot2{} and extends the grammar to genomic
  data with new features and extended components.
\end{itemize}


\section{Documentation}
From Bioconductor 2.11, I have two documentation:

\begin{itemize}
\item One is like all other bioconductor package, one single vignettes
  knited from sweave file. Yes, it's the one you are reading now. This vignette
  is trying to make a general tutorial for this graphical framework, with plenty
  of examples and case studies, following the logical order. 
\item The other source is under \ggbio{} official websites,
  \url{http://tengfei.github.com/ggbio}, under \textit{documentation} tab, I
  will use \knitr{} to knit the Rd manual and put it under manual
  section(\url{http://tengfei.github.com/ggbio/docs/man}), so all the help
  manual with examples code hybrided with graphics is shown there only. It's a
  very good companion for this pdf based vignette, or \R{} help, because you
  won't see vivid graphics in your help manual. Also more complete examples are
  present in the on-line help documentations too.
\end{itemize}

These two documentation are reproducible with the version of packages specified
in \Rcode{sessionInfo}, \knitr{} is the key to make them reproducible. For more
information about how those documentation generated, please visit \knitr{}'s
websites\footnote{\url{http://yihui.name/knitr/}}.

\section{Support}
As described on-line (\url{http://tengfei.github.com/ggbio/support.html}).

For issue/bug report and questions about usage, you could 
\begin{itemize}
\item File a issue/bug report at \url{https://github.com/tengfei/ggbio/issues}, 
  this will make sure I don't really forget to fix it later. \ggbio{} is a huge
  and flexible package, combination of components are not all tested, you
  probably could hit a bug or issue the future, I will appreciate it if you
  could let me know it and help me improve and fix the problem.
\item Send me email at yintengfei at gmail dot com  directly.
\item or ask question about \ggbio{} on biocondcutor.
\end{itemize}

\section{Installation}
As described on-line (\url{http://tengfei.github.com/ggbio/download.html}). 

\sfbox{Warn}{
  \textbf{github} is only used for issue/bugs report and homepage build purpose,
  developemnt has been stopped and removed from there already. I only use
  bioconductor to maintain and develop my package.
}

After R 2.15, R release cycle falls into annual release instead of semi-annual
release cycle, at the same time, Bioconductor project still follows semi-annual
release cycle. So now you can install both released and developmental version
for the same version of R.

In your R session, please run following code to install released version of
ggbio, but if you are using developmental version of R, you will get
developmental version of ggbio automatically. Because what you get depends on
the bioconductor installer, which is implemented in package BiocInstaller and
its version decides which version of Bioconductor you got.


<<install-release, eval = FALSE>>=
source("http://bioconductor.org/biocLite.R")
biocLite("ggbio")
@ %def 

After you run the code above, next time if you wish to install something new
from Bioconductor, you can simply run


<<install-release2, eval = FALSE>>=
library("BiocInstaller")
biocLite("ggbio")
@ %def 


Or you can check all released bioc packages here.

To install developmental version, run


<<install-devel, eval = FALSE>>=
library("BiocInstaller")
useDevel(TRUE)
biocLite("ggbio")
@ %def 


For developers, please you can find latest source code in bioc svn, username and
password are all "readonly"(without quotes).

\chapter{Tracks: bind and align plots}
\sfbox{To read this chapter, you don't need any background about biology. Basic
  knowledge about \ggplot{} is prefered.}

\section{Objective}
\begin{enumerate}
\item Get yourself familiar with basic \ggplot{} functions. 
\item Get yourself familiar with basic grammar of graphics.
\item Get yourself familiar with \ggbio{}'s \Rfunction{track} usage.
\end{enumerate}

\section{Motivation}
It might be surprising that the first chapter we are going to talk about is
about alignments of plots and especially for tracks. This is fundamental
components used almost everywhere in the documentations, what's more important,
this function could be used independently with \textbf{any other ggplot2
  graphics}, not just for graphics produced by \ggbio{}, well, this is the right
time to tell you that, \ggbio{} depends on \ggplot{} and extends it to genomic
world, \textbf{so every graphics produced by \ggbio{} is essentially a \ggplot{}
  object or a combination of them, so you can use any tricks works for \ggplot{}
  on \ggbio{} graphics.}, but of course, we bring more features which doesn't
exists in \ggplot{} at all.

\sfbox{If you want to manipulate graphics from \ggbio{} more freely, I strongly
  recommend you to read documentation about \ggplot{}, most time the edit you
  want could be achieved by some basic functionality already in \ggplot{}, so
  enjoy those handy tools and don't reinvent the wheel! What's more, if you want
  to be an expert, knowledge about \Rpackage{grid, gtable} are necessary. Tracks
  relies on the new \Rpackage{gtable} package heavily, it has several convenient
  ways to manipulate the graphic objects.}


Track-based view are widely used in almost all genome viewers, it usually stacks
multiple plots row by row and align them on exactly the same coordinate, which
in most cases, the genomic coordinates. In this way, we could be able to align
various annotation data against each other to make an efficient comparison. UCSC
genome browser\footnote{\url{http://genome.ucsc.edu/cgi-bin/hgGateway}} is one
of the most widely used track-based genome browser, as shown in Figure
\ref{fig:ucsc}. There are some other packages in \R{}, that support track-based
view like UCSC genome browser, such as \Rpackage{Gviz}. General tracks for
viewing genomic data should probably have following features:

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.8\textwidth]{figures/ucsc.png}
\end{figure}


\begin{itemize}
 \item Align each plot in exactly the same X coordinate(genomic coordinate).
 \item Naming ability for each track, this is different from Y-label, which is
   used to illustrate variable used as y.
 \item Shared ``scale'' track.
 \item Multiple ways to visualize the data, as points, line, bar chart or density.etc.
\end{itemize}

As comparison, \ggbio{} is trying to be even more general in terms of building
tracks, and offer more features.

\begin{itemize}
\item You can bind any graphics produced by \ggplot{}, not necessarily produced
  by \ggbio{}, in that way, \ggplot{} users will find it pretty conventient that
  they can construct plots independently, and \Rfunction{tracks} will align them
  for you. So you can use \Rfunction{tracks} to align your own data, e.g. time
  series data.
\item Easy-to-use utilities for zooming, backup, restore a view. This is useful
  when you tweak around with your best snapshot, so you can always go back.
\item A extended \textbf{"+"} method. If you are familiar with \ggplot{}'s
  \textbf{"+"} method to edit an existing plot, this is the way it works, if
  tracks is \textbf{"+"} with anything behind, it will be applied to each
  track. This make it easy to tweak with theme and update all the plots.
\item You could specify whether you want to label a plot or not by using
  \Rfunction{labeled, labeled<-}, and to specify whether you what the plot
  x-axis synchronized with other tracks or not by using function
  \Rfunction{fixed, fixed<-}.
\item Creating your own customized themes for not only single plot but also
  tracks! We will show an example how to create a theme called
  \Rfunction{theme\_tracks\_subset} in the following sections.
\item Support not only vertical alignments, but also horizontal alignments.
\end{itemize}

\sfbox{\Rfunction{tracks} function only support graphic objects produced by
  either \ggplot{} or \ggbio{}. If you want to align plots, produced by other
  grid based system, like lattice, users need to tweak in grid level, to insert
  a lattice grob to a layout.}

\section{Usage}
Function \Rfunction{tracks} is a constructor for an object with class
\Rclass{Tracks}. This object is a container for each plot you are going to
align, and all the graphic attributes controlling the appearance of tracks.

\subsection{A minimal example for \ggplot{} graphics}

Instead of showing you the genomic examples for constructing tracks, let me
first do a small favor for \ggplot{} users, suppose you don't have any
background about biology, all you want to do is to align two time series
data. We can construct any graphics \textbf{independently} without worrying
about aligning them. Just use your knowlegge about \ggplot{} to create any
simple or fancy graphics, only one thing you need to make sure about is that
\textbf{the x-axis you are going to align must have the same meanings}, in this
minimal example, it's \textit{time}. 

I am going to introduce some basic usage about \ggplot{} all the way through
this vignette every now and then, to make it easier for people who first use
\ggplot{} or \ggbio{} and not quite familiar with its grammar.


<<ts>>=
## load ggbio automatically load ggplot2
library(ggbio)
## make a simulated time series data set
df1 <- data.frame(time = 1:100, score = sin((1:100)/20)*10)
p1 <- qplot(data = df1, x = time, y = score, geom = "line")
df2 <- data.frame(time = 30:120, score = sin((30:120)/20)*10, value = rnorm(120-30 + 1))
p2 <- ggplot(data = df2, aes(x = time, y = score)) + 
  geom_line() + geom_point(size = 4, aes(color = value))
@ %def 

In \ggplot{}, most working object are \Rclass{data.frame}, in comparison, we
support many other core data structure in \Bioc{}, which we will introduce later
mainly in Section\ref{chapter:autoplot} and Section\ref{chapter:ggplot}, when we
introduce function generic method such as \Rfunction{autoplot} and
\Rfunction{ggplot}.

When you see \Rfunction{qplot} function, you have to know it's \ggplot{}'s
function(means 'quick plot'), since \Bioc{} 2.10, \ggbio{} stop using a
confusing generic \Rfunction{qplot} function, instead, we are using a new
generic method introduced in \ggplot{}, called \autoplot{}, we heavily override
this function in \ggbio{} to support more data structure.

To introduce \qplot{} function, we need to first get an idea about grammar of
graphics(GoG), it's basically composed of following components:
\begin{itemize}
\item \textit{Data}: Data you are going to visualize with a set of
  variables, it's usually the first argument passed in function \autoplot{}.
\item \textit{Statistical transformation}: Statistical methods performed on the
  variables of raw data and generate more informative summary. It's usually
  controlled by the parameters \textbf{stat}.
\item \textit{Geometric object}: e.g arrow, rectangle. It's usually controlled
  by the parameters \textbf{geom}.
\item \textit{Coordinate system}: eg Cartesian. It's usually controlled by the
  parameters \textbf{coord}.
\item \textit{Scales}:Transformation of scales, such as logarithm. It's usually
  controlled by the parameters \textbf{scale}.
\item \textit{Facetting}:Subset the data by factors and create small panels for
  each subset of data with same representation of graphics. It's usually
  controlled by the parameters \textbf{facets}.
\end{itemize}  

So basically speaking we have two API or usage here for constructing graphics in
\ggplot{}, it's similar in \ggbio{}. 
\begin{itemize}
\item The first method is called quick plot in \ggplot{}, implemented in
  function \qplot{}, it's one general wrapper for quick mapping and constructing
  the grammar's components. Similar in \ggbio{}, we have \autoplot{} for this
  purpose, what's more, \autoplot{} is more object-oriented visualization
  methods, which will be introduced in other chapter\ref{chapter:autoplot}. so
  in the \qplot{} API, we specify data to be the data frame and map x to
  \textit{time} variable and map y to \textit{score} varialbe, \Rfunarg{geom}
  arguments means \textit{Geometric objects}, we could use multiple
  \textit{geom} in \qplot{} function. To print the graphic object on the screen,
  simply call \Rfunction{print} on it or just type the name and show it.
\item The second method is very flexible or more close to the grammar itself,
  the way it is constructed is like the way it is described in the grammar or
  like in plain human languange. Let's say we want to ``use data df2, and
  generally use \textit{time} as x and use \textit{score} as y, then we add a
  line to the plot, next we add points to the plots, for those points, we want
  to map color to \textit{value} varialbe and use arbitrary value to set size
  for points''. See, it is exactly what we described compared to the actuall
  code! That's what \ggplot{} bring to us, the implmentation of grammar of
  graphics in \R{}. Notice, function \Rfunction{aes} used for mapping
  \textit{aesthetics} to variables in the data. 
\end{itemize}

\sfbox{If you don't know how many existing components you could use in pure
  \ggplot{} package, please check Hadley's online documentation. Websites is
  here \url{http://had.co.nz/ggplot2/}, For \ggbio{} based components, please
  read relevant part in this vignettes and visit
  \url{http://tengfei.github.com/ggbio/docs} to check documentation. There are
  plenty of examples with graphics there.}


<<ts-plot, fig.show = "hold", fig.width = 3, fig.height = 3, fig.cap = "Two time series plots with slightly different x-axis">>=
print(p1)
p2
@ %def 

As shown in Figure \ref{fig:ts-plot}, we can see these two plots have different
scale on x-axis, but we want to compare those two plots and hope to align them
on exactly the same x-axis scale, then we could make vertical comaprison
easily. Now we introduce the \tracks{} function, we can pass the multiple plots
we want to align into it, and it will do some obvious modification including :
\begin{itemize}
\item squeeze the plots together
\item remove x-axis and make a shared scale.  
\item do the alignments automatically.
\item construct and return a \Rclass{tracks} object.
\end{itemize}


<<ts-track, fig.cap = "tracks for two time series plots">>=
tracks(p1, p2)
@ %def 

As shown in Figure \ref{fig:ts-track}, those two plots are aligned well on the
x-axis, so here it is, our first track. You could also assign the tracks to an
object, this will avoid printing on the screen immediately.

<<ts-track-uneval, eval = FALSE>>=
tks <- tracks(p1, p2)
tks
@ %def 

\subsection{Labeling and naming a track}
Y labels are kept for each track plot, but in general, you may want to annotate
the plot for title or x label, just specify arguments in \tracks{} function.

<<ts-track-xlab>>=
tracks(p1, p2)
tracks(p1, p2, xlab = "xlab", main = "main")
@ %def 

To add label for each track, simply naming the plots, there are several ways to
label it.
\begin{itemize}
\item pass names togther with graphics.
\item for complicated name, use quotes.
\item use named list of graphics  
\end{itemize}

As shown below in following examples.
@ 
<<ts-track-label>>=
## labeling: default labeling a named graphic
## simply pass a name with it
tracks(time1 = p1, time2 = p2)
## or pass a named list with it
lst <- list(time1 = p1, time2 = p2)
tracks(lst)
## more complicated case please use quotes
tracks(time1 = p1, "second time" = p2)
@ %def 

Sometimes, even though you passed a named or no-name graphics, but you still
don't the gracks to show the label background for that plot, you can simply set
the labeled attribute of plot to be \Rcode{FALSE}.


<<ts-labeled>>=
labeled(p2) 
labeled(p2) <- FALSE
## set labeled to FALSE, remove label even the plot has a name
tracks(time1 = p1, time2 = p2)
labeled(p2) <- TRUE
@ %def 


\subsection{Modification}
% height
To modify the heights for each track, simply pass the \Rfunarg{heights} argument
with ratio.

<<ts-height>>=
## set heights
tracks(time1 = p1, time2 = p2, heights = c(1, 3))
@ %def 

To change background for each plot, you could set \textbf{bgColor} attribute or
use argument \Rfunarg{track.plot.color}.

<<ts-bgcolor>>=
## bgColor
bgColor(p1)
tracks(time1 = p1, time2 = p2)
bgColor(p1) <- "brown"
# mutable for "+" method
tracks(time1 = p1, time2 = p2)
# set it back
bgColor(p1) <- "white"
@ %def 


<<ts-track-col>>=
## track color
tracks(time1 = p1, time2 = p2, track.bg.color = "yellow")
tracks(time1 = p1, time2 = p2, track.plot.color = c("yellow", "brown"))
@ %def 

To control axis, you could set attribute \textbf{hasAxis}.
@ 
<<ts-axis>>=
hasAxis(p1)
hasAxis(p1) <- TRUE
# ready for weird looking
tracks(time1 = p1, time2 = p2)
hasAxis(p1) <- FALSE
@ %def 


Arith method

%fixed
@ 
<<ts-fixed>>=
## fix a plot, not synchronize with other plots
p3 <- p1
## default is always FALSE
fixed(p3)
## set to TRUE
fixed(p3) <- TRUE
fixed(p3)
tracks(time1 = p1, time2 = p2, "time3(fixed)" = p3) 
fixed(p3) <- FALSE
## otherwise you could run
tracks(time1 = p1, time2 = p2, "time3(fixed)" = p3, fixed = c(FALSE, FALSE, TRUE))
@ %def 

%mutable
@ 
<<ts-mutable>>=
## mutable
mutable(p1)
tracks(time1 = p1, time2 = p2) + theme_bw()
mutable(p1) <- FALSE
# mutable for "+" method
tracks(time1 = p1, time2 = p2) + theme_bw()
mutable(p1) <- TRUE
@ %def 



\subsection{Customized themes for plots and tracks}
@ 
<<ts-theme>>=
## apply a theme to each track
tks <- tracks(time1 = p1, time2 = p2) + theme_bw()
tks
reset(tks)

## store it with tracks
tks <- tracks(time1 = p1, time2 = p2, theme = theme_bw())
tks
tks <- tks + theme_gray()
tks
## reset will be introduced later
reset(tks)

## apply a pre-defiend theme for tracks!
tracks(time1 = p1, time2 = p2) + theme_tracks_sunset()
 tracks(p1, p2) + theme_tracks_sunset()
@ %def 
\subsection{Zoom in/out}
@ 
<<ts-xlim>>=
tracks(time1 = p1, time2 = p2) + xlim(1, 40)
tracks(time1 = p1, time2 = p2) + xlim(1, 40) + ylim(0, 10)
tracks(time1 = p1, time2 = p2) + xlim(1, 40) + ylim(0, 10)
library(GenomicRanges)
gr <- GRanges("chr", IRanges(1, 40))
# GRanges
tracks(time1 = p1, time2 = p2) + xlim(gr)
# IRanges
tracks(time1 = p1, time2 = p2) + xlim(ranges(gr))
tks <- tracks(time1 = p1, time2 = p2)
xlim(tks)
xlim(tks) <- c(1, 35)
xlim(tks) <- gr
xlim(tks) <- ranges(gr)
@ %def 


\subsection{Backup/restore utilities}
@ 
<<>>=
tks <- tracks(time1 = p1, time2 = p2)
tks
tks <- tks + xlim(1, 40)
tks
reset(tks)
tks <- tks + xlim(1, 40)
tks
tks <- backup(tks)
tks <- tks + theme_bw()
tks
reset(tks)
@ %def 



\section{Discussion}
\chapter{Theme: all about design and beauty.}
\chapter{\Rfunction{ggplot} generic method and low level
  components}\label{chapter:ggplot}
\chapter{\Rfunction{mold} method}
\chapter{\Rfunction{Autoplot} }\label{chapter:autoplot}
\section{API}
API about is \autoplot{} is kind of like a wrapper around the grammar. If you are
familiar with API of \ggplot{}, it's very similar. 

\begin{verbatim}
autoplot(object = , geom = , stat = , coord = , facets = , scale = , ...)
\end{verbatim}

Most time only \Rfunarg{object} parameters are required, and we have default for
all other components, \ggbio{} have default for each object trying to make smart
guess for user's purpose for particular data. \Rfunarg{...} means for particular
data we accept or sometimes require extra arguments to control the graphics. For
example, in some cases, like for a \Robject{TranscriptDb} object, user has to
pass a \Rfunarg{which} argument to tell \ggbio{} which region you want to
visualize, not the entire genome which make no sense here. 

\section{Usage}
\subsection{autoplot,GRanges}\label{sec:gr}
\autoplot{} for \Robject{GRanges} object is designed to be most general plot API
in \ggbio{} package. \Robject{GRanges} is most suitable data structure for
storing interval data with medata data, which could be used for representing a
set of short reads or genomic features.

Supported geom designed specifically for \Robject{GRanges}, including "rect",
"chevron", "alignment", "arrowrect", "arrow", "segment", "arch", and special
statistical transformation contains "identity", "coverage", "stepping",
"aggregate", "table", "gene", "mismatch". And they are implemented in lower API,
such as \Rfunction{geom\_alignment} and \Rfunction{stat\_coverage}. If you pass
other 'geom'and 'stat' other than those ones, it first use 'fortify' method in
\ggbio{} to coerce a \Robject{GRanges} into a 'data.frame' object. And a new
variable 'midpoint' is created and added to final 'data.frame' to be used to
mapped as 'x'. So you can use it as other \ggplot{} API.


Inside, \autoplot{} will choose the best choice for your combination of 'geom'
and 'stat'.

For aesthetics mapping now, users have to pass them to \Rfunction{aes()}
functions and pass it into \autoplot{}, for example


<<auto-color-score, eval = FALSE>>=
autoplot(data, color = score)
## this  won't work, you have to use 
autoplot(data, aes(color = score))
@ %def 

For arbitrary setting like you just want to use ``red'' for your fill color,
don't wrap it in your code.

@ 
<<auto-fill-arby>>=
autoplot(data, aes(color = score), fill = "red")
@ %def 


\sfbox{}{
  This is very different from design of \qplot{} API in \ggplot{} package, I
  \textbf{force} users to pass the mapping in \Rfunction{aes}. This allow you to
  wrap the function into your own customized function and make sure the
  evaluation accurate. 
}
	
Let's generate some simulated interval data and store it as \Robject{GRanges} object.
<<simul>>=
set.seed(1)
N <- 1000
library(GenomicRanges)
gr <- GRanges(seqnames = 
              sample(c("chr1", "chr2", "chr3"),
                     size = N, replace = TRUE),
              IRanges(
                      start = sample(1:300, size = N, replace = TRUE),
                      width = sample(70:75, size = N,replace = TRUE)),
              strand = sample(c("+", "-", "*"), size = N, 
                replace = TRUE),
              value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              sample = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))

idx <- sample(1:length(gr), size = 50)
@ %def 
\clearpage

Let's first take a look at a general table about stat/geom/layout/coord/scale,
\autoplot{} for \Robject{GRanges} supported, this table is just a subset and
will keep completing with more.

\begin{table}[h!t!b!p]
\begin{center}
\small{
\begin{tabular}{|p{1.4cm}|p{3cm}|p{8cm}|p{0.6cm}|}
\hline
Comp & name  & usage & icon\\\hline
\textbf{geom} &geom\_rect & rectangle& \includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_rect.pdf}\\
              &geom\_segment & segment& \includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_segment.pdf}\\
              &geom\_chevron & chevron&\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_chevron.pdf}\\
              &geom\_arrow & arrow&\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_arrow.pdf}\\
              &geom\_arch & arches &\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_arch.pdf}\\
              &geom\_bar & bar &\includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_bar.pdf}\\
              &geom\_alignment & alignment (gene) & 
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/geom_alignment.pdf}\\\hline
\textbf{stat} 
              &stat\_coverage & coverage (of reads) &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_coverage_icon.pdf}\\
              &stat\_mismatch & mismatch pileup for alignments &
              \includegraphics[height = 0.25cm,width = 0.6cm]{figures/stat_mismatch.pdf}\\
              &stat\_aggregate & aggregate in sliding window &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_aggregate.pdf}\\
              &stat\_stepping & avoid overplotting &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_stepping.pdf}\\
              &stat\_gene & consider gene structure &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_gene.pdf}\\
              &stat\_table & tabulate ranges &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_table.pdf}\\
              &stat\_identity & no change &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/stat_identity.pdf}\\\hline
\textbf{coord} &linear& ggplot2 linear but facet by chromosome &
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_linear.pdf}\\
               &genome& put everything on genomic coordinates&
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_genome.pdf}\\
               &truncate gaps & compact view by shrinking gaps&
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_truncate_gaps.pdf}\\\hline
\textbf{layout}& track & stacked tracks &\includegraphics[height = 0.25cm, width = 0.6cm]{figures/coord_linear.pdf}\\
              &karyogram & karyogram display &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/layout_karyogram.pdf}\\
              &circle & circular &
              \includegraphics[height = 0.25cm, width = 0.6cm]{figures/layout_circle.pdf}\\\hline
\textbf{faceting}&formula & facet by formula &
               \includegraphics[height = 0.25cm, width = 0.6cm]{figures/facet.pdf}\\
                 &ranges & facet by ranges &
                 \includegraphics[height = 0.25cm, width = 0.6cm]{figures/facet_gr.pdf}\\\hline
\textbf{scale} &not extended  & \ggplot{}default& \\\hline
\end{tabular}
}
\end{center}
\caption{Components of the basic grammar of graphics, with the extensions available in 
\ggbio{}.}
\label{tab:components}
\end{table}

Default is to use geom "rect" to represent those 'short reads', show overlaped
intervals on different levels to help visualize the data.
% \begin{figure}[!htpb]
%   \centering

<<default-gr, fig = TRUE>>=
autoplot(gr[idx])
@ %def  
%   \caption{gr-default}
%   \label{fig:gr-default}
% \end{figure}
% \clearpage

Geom 'bar'just show intervals' region as they are and use a sepcified y in
\Rfunction{aes()} to show as the height of bars, default is to use 'score' in
the data if exists, because in most genomic data format, such as BED format, the
score are reserved column.

<<bar-default-pre>>=
set.seed(123)
gr.b <- GRanges(seqnames = "chr1", IRanges(start = seq(1, 100, by = 10),
                  width = sample(4:9, size = 10, replace = TRUE)),
                score = rnorm(10, 10, 3), value = runif(10, 1, 100))
gr.b2 <- GRanges(seqnames = "chr2", IRanges(start = seq(1, 100, by = 10),
                  width = sample(4:9, size = 10, replace = TRUE)),
                score = rnorm(10, 10, 3), value = runif(10, 1, 100))
gr.b <- c(gr.b, gr.b2)
head(gr.b)
@ %def 

% \begin{figure}[!htpb]
%   \centering
<<bar-default, fig = TRUE, fig.cap = "Bar geom for GRanges.">>=
p1 <- autoplot(gr.b, geom = "bar")
## use value to fill the bar
p2 <- autoplot(gr.b, geom = "bar", aes(fill = value))
tracks(default = p1, fill = p2)
@ %def   
%   \caption{Bar geom for GRanges.}
%   \label{fig:gr-bar}
% \end{figure}
% \clearpage

Facetting, some combination of geom/stat
@ 
<<fig = TRUE>>=
autoplot(gr[idx], geom = "arch", aes(color = value), facets = sample ~ seqnames)
@ %def 

Group need to be specified in \Rfunction{aes()} use aesthetics \Rfunarg{group},
this help to assign grouped intervals showing on the same y level, especially ,
when you use \Rfunarg{geom} 'alignment', gaps will be created based on group
information and shown on the plot. A minimal example is shown in the following
chunks.  
% \begin{figure}[!htpb]
%   \centering
@ 
<<gr-group, fig = TRUE, fig.cap = "Grouping method comparison for geom alignment.">>=
gra <- GRanges("chr1", IRanges(c(1,7,20), end = c(4,9,30)), group = c("a", "a", "b"))
## if you desn't specify group, then group based on stepping levels, and gaps are computed without
## considering extra group method
p1 <- autoplot(gra, aes(fill = group), geom = "alignment")
## when use group method, gaps only computed for grouped intervals.
## default is group.selfish = TRUE, each group keep one row.
## in this way, group labels could be shown as y axis.
p2 <- autoplot(gra, aes(fill = group, group = group), geom = "alignment")
## group.selfish = FALSE, save space
p3 <- autoplot(gra, aes(fill = group, group = group), geom = "alignment", group.selfish = FALSE)
tracks('non-group' = p1,'group.selfish = TRUE' = p2 , 'group.selfish = FALSE' = p3)
@ %def   
%   \caption{Grouping method comparison for geom alignment.}
%   \label{fig:gr-group}
% \end{figure}
% \clearpage
Faceted by strand help you understand coverage from different sequencing direction. 
% \begin{figure}[!htpb]
%   \centering
@ 
<<gr-facet-strand, fig = TRUE, fig.cap = "Facet by strand to show coverage.">>=
autoplot(gr, stat = "coverage", geom = "area", 
         facets = strand ~ seqnames, aes(fill = strand))
@ %def   
%   \caption{Facet by strand to show coverage.}
%   \label{fig:facet-strand}
% \end{figure}
% \clearpage
New coordinate transformation 'genome' will transform a \Robject{GRanges} object
into a genome space, align them up based on 'seqlevel' orders. This
transformation allows you to add 'seqlengths' to your \Robject{GRanges} object
to produce a fixed width. and add buffer in between by specifying
\Rfunarg{space.skip}. This transformation is useful for grand linear view as
Manhattan plot or circular view.

Please read another two vignette about how to plot Manhattan plot and generate
circular view for detail.
% \begin{figure}[!htpb]
%   \centering
<<gr-autoplot-circle, fig = TRUE, fig.cap = "minimal example for circular transformation.">>=
autoplot(gr[idx], layout = 'circle') 
@ %def   
%   \caption{minimal example for circular transformation.}
%   \label{fig:gr-circle}
% \end{figure}
% \clearpage

A little more 
% \begin{figure}[!htpb]
%   \centering

<<gr-circle, fig = TRUE, fig.cal = "Circular layout minimal example.">>=
seqlengths(gr) <- c(400, 500, 700)
values(gr)$to.gr <- gr[sample(1:length(gr), size = length(gr))]
idx <- sample(1:length(gr), size = 50)
gr <- gr[idx]
ggplot() + layout_circle(gr, geom = "ideo", fill = "gray70", radius = 7, trackWidth = 3) +
  layout_circle(gr, geom = "bar", radius = 10, trackWidth = 4, 
                aes(fill = score, y = score)) +
  layout_circle(gr, geom = "point", color = "red", radius = 14,
                trackWidth = 3, grid = TRUE, aes(y = score)) +
  layout_circle(gr, geom = "link", linked.to = "to.gr", radius = 6, trackWidth = 1)
@ %def 
%   \caption{Circular layout minimal example.}
%   \label{fig:gr-circle}
% \end{figure}
% \clearpage

You will find a more general tutorial for circular view in chapter \ref{chapter:circle}

\subsection{autoplot,Seqinfo}
When a \Robject{GRanges} has seqlengths information which defined chromomsome
lengths, we have a way to quickly give a karyogram overview for adding data on
later. Please read another vignette about karyogram overview. 

You can easily subset/re-order the visualized the chromosomes by using '[' method.

<<seqinfo-src>>=
data(hg19Ideogram, package = "biovizBase")
sq <- seqinfo(hg19Ideogram)
sq
@ %def 
% \clearpage
% \begin{figure}[!htpb]
%   \centering

<<seqinfo, fig = TRUE, fig.cap = "Seqinfo visualization for chromosomes 1 to 22 and X.">>=
autoplot(sq[paste0("chr", c(1:22, "X"))])
@ %def   
%   \caption{Seqinfo visualization for chromosomes 1 to 22 and X.}
%   \label{fig:seqinfo}
% \end{figure}

% \clearpage

\subsection{autoplot,IRanges}
\Rfunction{autoplot} for \Robject{IRanges} is used to visualize simple interval
data with element data together.

Supported geom designed specifically for \Robject{IRanges}, including "rect",
"chevron", "alignment", "arrowrect", "arrow", "segment", "arch", and special
statistical transformation contains "identity", "coverage", "stepping",
"aggregate", "table", "gene", "mismatch". And they are implemented in lower API,
such as \Rfunction{geom\_alignment} and \Rfunction{stat\_coverage}. If you pass
other \Rfunarg{geom} and \Rfunarg{stat} other than those ones, it first coerces
a \Robject{IRanges} into a \Robject{data.frame} object together with extra
element meta data, and added to \Robject{data.frame}.


Inside, \Robject{autoplot} will choose the best choice for your combination of
\Rfunarg{geom} and \Rfunarg{stat}.

Let's generate some simulated interval data and store it as *IRanges*
object. and add some element meta data.
@ 
<<ir-load>>=
set.seed(1)
N <- 100
ir <-  IRanges(start = sample(1:300, size = N, replace = TRUE),
               width = sample(70:75, size = N,replace = TRUE))
## add meta data 
df <- DataFrame(value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              sample = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))
values(ir) <- df
ir
@ %def 

\autoplot{} will coerce \Robject{IRanges} together with its element meta data, so
aesthetics mapping works for those extra information too.
% \begin{figure}[!htbp]
%   \centering
<<ir-exp, fig = TRUE, fig.cap = "IRanges visualization.">>=
p1 <- autoplot(ir)
p2 <- autoplot(ir, aes(fill = pair)) + opts(legend.position = "none")
p3 <- autoplot(ir, stat = "coverage", geom = "line", facets = sample ~. )
p4 <- autoplot(ir, stat = "reduce")
tracks(p1, p2, p3, p4)
@ %def   
%   \caption{IRanges visualization.}
%   \label{fig:ir-v}
% \end{figure}
% \clearpage

\subsection{autoplot,GRangesList}
\Robject{GRangesList} is most suitable data structure for storing a set of genomic
 features, for example, exons/utrs in a gene. `autoplot` is designed to consider
 the native grouping information in this structure and automatically showing
 gaps within group in `geom` *alignment* and make sure grouped items are shown
 together on the same level with nothing falling in between.

 Argument \Rfunarg{main.geom} and \Rfunarg{gap.geom} control geometry for
 entities and gaps computed for them. \Rfunarg{group.selfish} help you put
 grouped items in unique y levels and show the y labels for group names.

Let's create a \Robject{GRangesList} object by splitting a \Robject{GRanges} object.

<<grl-simul>>=
set.seed(1)
N <- 100
## ======================================================================
##  simmulated GRanges
## ======================================================================
gr <- GRanges(seqnames = 
              sample(c("chr1", "chr2", "chr3"),
                     size = N, replace = TRUE),
              IRanges(
                      start = sample(1:300, size = N, replace = TRUE),
                      width = sample(30:40, size = N,replace = TRUE)),
              strand = sample(c("+", "-", "*"), size = N, 
                replace = TRUE),
              value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              sample = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))


grl <- split(gr, values(gr)$pair)
@ %def 

For \Robject{GRangesList} object, default is coerce it to \Robject{GRanges} and
adding extra column to preserve the grouping information. main geoms and gaps
geom are separately controlled.  
% \begin{figure}[!htpb]
%   \centering

<<grl-exp, fig = TRUE, fig.cap = "Some examples showing GRangesList">>=
## default gap.geom is 'chevron'
p1 <- autoplot(grl, group.selfish = TRUE)
p2 <- autoplot(grl, group.selfish = TRUE, main.geom = "arrowrect", gap.geom = "segment")
tracks(p1, p2)
@ %def   
%   \caption{Some examples showing GRangesList}
%   \label{fig:grl-exp}
% \end{figure}
% \clearpage

Internal variable \Rfunarg{grl\_name} added to keep a track for grouping
information, you could use it for faceting or other aesthetic mapping, the
variables could be renamed by \Rfunarg{indName} argument in \autoplot{}, you
could pass either \Rcode{..grl\_name..} or \Rcode{grl\_name} in the mapping, I
prefer the first one, it tells that it's interval variables.  
% \begin{figure}[!htpb]
%   \centering

<<grl-name, fig = TRUE, fig.cap = "Tweak with name.">>=
autoplot(grl, aes(fill = ..grl_name..))
## equal to 
## autoplot(grl, aes(fill = grl_name))
@ %def   
%   \caption{Tweak with name.}
%   \label{fig:grl-name}
% \end{figure}
% \clearpage

\subsection{autoplot,Rle}
\Robject{Rle} is a general container for storing atomic vector which is defined
in package \Robject{IRanges}, data is stored in a run-length encoding format.

For \Robject{Rle}, we bring following method, three stat, two geom and four types.

Two geom
\begin{itemize}
\item \textbf{bar}: default, controlled by 'nbin'.
\item \textbf{heatmap}: show Rle as heatmap, use color to indicate values,
  controlled by 'nbin'.
\end{itemize}

Three default statistical transformation
\begin{itemize}
\item \textbf{bin}: bin the object, default is 30 bins in the view, controlled
  by argument \Rfunarg{nbin}. Then in each bin make summary against specified
  types.
\item \textbf{identity}: transform data to raw vector, then you can use many
  other geom such as line or point. Default x and y is internally set to
  position and value.
\item \textbf{slice}: use \Rfunarg{lower} to slice the object to islands, then
  use bar or heatmap to represent the island.
\end{itemize}

Four types for compute the statistical summary.
\begin{itemize}
\item \textbf{viewSums}: sums in the sliced view or bins.
\item \textbf{viewMins}: min values in the sliced view or bins.
\item \textbf{viewMaxs}: max values in the sliced view or bins.  
\item \textbf{viewMeans}: mean values in the sliced view or bins.    
\end{itemize}

Let's simulate some data first.

<<rle-simul>>=
library(IRanges)
library(ggbio)
set.seed(1)
lambda <- c(rep(0.001, 4500), seq(0.001, 10, length = 500), 
            seq(10, 0.001, length = 500))

## @knitr create
xVector <- rpois(1e4, lambda)
xRle <- Rle(xVector)
xRle
@ %def 


 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<rle-bin, fig = TRUE, fig.cap = "Compare different geom and nbin by using default bin stat.">>=
p1 <- autoplot(xRle)
p2 <- autoplot(xRle, nbin = 80)
p3 <- autoplot(xRle, geom = "heatmap", nbin = 200)
tracks('nbin = 30' = p1, "nbin = 80" = p2, "nbin = 200(heatmap)" = p3)
@ %def 
%   \caption{Compare different geom and nbin by using default bin stat.}
%   \label{fig:rle-bin}
% \end{figure}
% \clearpage


 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<rle-id, fig = TRUE, fig.cap = "Compare different geom and nbin by using stat identity.">>=
p1 <- autoplot(xRle, stat = "identity")
p2 <- autoplot(xRle, stat = "identity", geom = "point", color = "red")
tracks('line' = p1, "point" = p2)
@ %def 
%   \caption{Compare different geom and nbin by using stat identity.}
%   \label{fig:rle-id}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering

<<rle-slice, fig = TRUE, fig.cap = "Compare different geom and nbin by using stat slice.">>=
p1 <- autoplot(xRle, type = "viewMaxs", stat = "slice", lower = 5)
p2 <- autoplot(xRle, type = "viewMaxs", stat = "slice", lower = 5, geom = "heatmap")
tracks('bar' = p1, "heatmap" = p2)
@ %def 
%   \caption{Compare different geom and nbin by using stat slice.}
%   \label{fig:rle-slice}
% \end{figure}
% \clearpage




\subsection{autoplot,RleList}
All methods are the same for \Robject{RleList} as for \Robject{Rle}, it's just
faceted by listed group automatically. Please read the autoplot,Rle section first.

Let's simulate some data first.

<<rlel-simul>>=
xRleList <- RleList(xRle, 2L * xRle)
xRleList
@ %def 


 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<rlel-bin, fig = TRUE, fig.cap = "Compare different geom and nbin by using default bin stat.">>=
p1 <- autoplot(xRleList)
p2 <- autoplot(xRleList, nbin = 80)
p3 <- autoplot(xRleList, geom = "heatmap", nbin = 200)
tracks('nbin = 30' = p1, "nbin = 80" = p2, "nbin = 200(heatmap)" = p3)
@ %def 
%   \caption{Compare different geom and nbin by using default bin stat.}
%   \label{fig:rlel-bin}
% \end{figure}
% \clearpage

 
 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<rlel-id, fig = TRUE, fig.cap = "Compare different geom and nbin by using stat identity.">>=
p1 <- autoplot(xRleList, stat = "identity")
p2 <- autoplot(xRleList, stat = "identity", geom = "point", color = "red")
tracks('line' = p1, "point" = p2)
@ %def 
%   \caption{Compare different geom and nbin by using stat identity.}
%   \label{fig:rlel-id}
% \end{figure}
% \clearpage

 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<rlel-slice, fig = TRUE, fig.cap = "Compare different geom and nbin by using stat slice.">>=
p1 <- autoplot(xRleList, type = "viewMaxs", stat = "slice", lower = 5)
p2 <- autoplot(xRleList, type = "viewMaxs", stat = "slice", lower = 5, geom = "heatmap")
tracks('bar' = p1, "heatmap" = p2)
@ %def 
%   \caption{Compare different geom and nbin by using stat slice.}
%   \label{fig:rlel-slice}
% \end{figure}
% \clearpage

\subsection{autoplot,TranscriptDb}
Please read another vignette called \textit{How to plot genomic features by
  using \Robject{TranscriptDb} object}

Some simple demonstration:

<<txdb>>=
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
data(genesymbol, package = "biovizBase")
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
@ %def 

\clearpage \Rfunarg{which} argument accept a \Robject{GRanges, list} which is
\textbf{required} to subset the data. \Rfunarg{names.expr} accept string pattern
or expression to parse the y tick labels. Otherwise it's not going to show all
of them. We are trying to show the ALDOA gene in the following example.
% \begin{figure}[!htpb]
%   \centering

<<txdb-visual, fig = TRUE, fig.cap = "TranscriptDb visualziation. Top track shows all the transcripts while bottom track reduce them and show a single track.">>=
p1 <- autoplot(txdb, which = genesymbol["ALDOA"], names.expr = "tx_name:::gene_id")
p2 <- autoplot(txdb, which = genesymbol["ALDOA"], stat = "reduce", color = "brown", 
               fill = "brown")
tracks(full = p1, reduce = p2, heights = c(5, 1)) + ylab("")
@ %def   
% \caption{TranscriptDb visualziation. Top track shows all the transcripts while
%   bottom track reduce them and show a single track.}
%   \label{fig:txdb-v}
% \end{figure}

\subsection{autoplot,GappedAlignment}\label{sec:gapped}
The \Robject{GappedAlignments} class is a container to store a set of
alignments, which is defined in package \Rpackage{GenomicRanges}. 

Let's load some data.

<<ga-load>>=
library(Rsamtools)
data("genesymbol", package = "biovizBase")
bamfile <- system.file("extdata", "SRR027894subRBM17.bam", package="biovizBase")
## need to set use.names = TRUE
ga <- readBamGappedAlignments(bamfile,
                              param = ScanBamParam(which = genesymbol["RBM17"]),
                              use.names = TRUE)
@ %def 

Default is to show gapped line, we also could show them as simple short reads
and coverage.
 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<ga-exp, fig = TRUE, fig.cap = "Visualization of GappedAlignemnt object">>=
p1 <- autoplot(ga)
p2 <- autoplot(ga, geom = "rect")
p3 <- autoplot(ga, geom = "line", stat = "coverage")
tracks(default = p1, rect = p2, coverage = p3)
@ %def   
%   \caption{Visualization of GappedAlignemnt object}
%   \label{fig:ga-v}
% \end{figure}

\subsection{autoplot,BamFile}\label{sec:bamfile}
For \Robject{BamFile}, we bring a fast estimated method(implemented by Michael
Lawrence), which is suitable for overview for particular chromosome and a much
slower raw data view which could be used in visualizing a small region.

Load some raw data first, we didn't provide an attached data here, you can try
to download a whole genome NGS seq file fro ENCODE or somewhere else.

<<bf-load, eval = FALSE>>=
library(Rsamtools)
bamfile <- "./wgEncodeCaltechRnaSeqK562R1x75dAlignsRep1V2.bam"
bf <- BamFile(bamfile)
@ %def 

A very efficient method called 'estimate', \Rfunarg{which} argument accepted a
chromsome names, will give you an overview about coverage. If multiple
chromosome names are provided, it will be faceted by seqnames. If which is
missing, it's going to use the first chromosomes appeared in the header.


<<bf-est-cov, eval = FALSE>>=
autoplot(bamfile)
autoplot(bamfile, which = c("chr1", "chr2"))
autoplot(bf)
autoplot(bf, which = c("chr1", "chr2"))

data(genesymbol, package = "biovizBase")
autoplot(bamfile,  method = "raw", which = genesymbol["ALDOA"])

library(BSgenome.Hsapiens.UCSC.hg19)
autoplot(bf, stat = "mismatch", which = genesymbol["ALDOA"], bsgenome = Hsapiens)
@ %def 


\subsection{autoplot,character}
When the object is character it accept a file with extensions \textit{.bam } or
any other extension names package \Rpackage{rtracklayer} supported, such as
\textit{.bed, .gif}. If the object could be imported by \Rpackage{rtracklayer},
it will be turned into a \Robject{GRanges} object, and 'score' column will be
potentially used.  So please read Section \ref{sec:gr} Section
\ref{sec:gapped} Section \ref{sec:bamfile} for related topics. 

For example, if you have a bam file

<<char-bam, eval = FALSE>>=
bamfile <- "./wgEncodeCaltechRnaSeqK562R1x75dAlignsRep1V2.bam"
autoplot(bamfile)
@ %def 

Or for an example bed file, remember you can pass an argument \Rfunarg{which} to
subset the data.
 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<char-gr, fig = TRUE, fig.cap = "autoplot for bed files">>=
library(rtracklayer)
test_path <- system.file("tests", package = "rtracklayer")
test_bed <- file.path(test_path, "test.bed")
autoplot(test_bed, aes(fill = name))
@ %def   
%   \caption{autoplot for bed files}
%   \label{fig:char-bed}
% \end{figure}

\subsection{autoplot,matrix}
For object \Robject{matrix}, the default graphic would be heatmap, here we bring
more controls over it.
\begin{itemize}
\item Argument \Rfunarg{genomic.pos} controls whether you want to show heatmap
  on genomic scale, which means, if set to \Rcode{TRUE}, this means the column
  name of matrix would be genomic position, so the heatmap is going to be
  distributed along genome and filled with blank cell. If weird things happens
  when the space is huge, some information may be lost(this have not been fixed
  yet), so a 'compact' version(default) will be recommended, unless you want to
  bind this track with other tracks by using \Rfunction{tracks} function. 
\item Function \Rfunction{scale\_fill\_fold\_change}(not default) will scale the heatmap due to
  a classic blue-white-red color scheme, where 0 is set to white color, negative
  value set to blue and positive value set to red.
\end{itemize}

This underlies fundamental heatmap for other object such as
\Robject{ExpressionSet, SummarizedExperiment, VCF}, which we will introduce
later.

We use \Robject{volcano} default data as an example, it's not a real microarray
data, just demonstrate how to visualize a \Robject{matrix}.
 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<matrix-default, fig = TRUE, fig.cap = "Default graphic for matrix object is heatmap.">>=
autoplot(volcano)
@ %def   
%   \caption{Default graphic for matrix object is heatmap.}
%   \label{fig:matrix-default}
% \end{figure}
% \clearpage

In biological papers, a blue-white-scale is commonly used for making heatmap.
 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<matrix-default-scale, fig = TRUE, fig.cap = "Default graphic for matrix object is heatmap. We scale them to blue-white-red color scheme.">>=
autoplot(volcano-150)+scale_fill_fold_change()
@ %def   
%   \caption{Default graphic for matrix object is heatmap. We scale them to
%     blue-white-red color scheme.}
%   \label{fig:matrix-default-scale}
% \end{figure}
% \clearpage

Use column names to indicate genome position. 
 % \begin{figure}[!htpb]
 %   \centering
 % @ 
<<matrix-default-gene, fig = TRUE, fig.cap = "Default graphic for matrix object is heatmap, we plot matrix to a genomic position based on assumption that column names are genomic positions.">>=
colnames(volcano) <- sort(sample(1:300, size = ncol(volcano), replace = FALSE))
autoplot(volcano-150, genomic.pos = TRUE)+scale_fill_fold_change()
@ %def   
%   \caption{Default graphic for matrix object is heatmap, we plot matrix to a
%     genomic position based on assumption that column names are genomic
%     positions. }
%   \label{fig:matrix-default-gene}
% \end{figure}
% \clearpage

\subsection{autoplot, ExpressionSet}
\Robject{ExpressionSet} object is commonly used container for storing
high-throughput assays and experimental metadata. it's defined in
\Rpackage{Biobase}.

Graphics we bring for this type of data includes:
\begin{itemize}
\item 'heatmap': default.  
\item 'pcp': parallel coordinate plots, level change for particular gene(row)
  can be easily observed cross samples.
\item 'boxplot': boxplot, summary over samples.
\item 'scatterplot.matrix' pairwised comparison across samples, a quick way to
  observe correlation.   
\item other specific experimental types may require loading other packages, such as types
  'mean-sd' and 'volcano'.
\end{itemize}

Let's have some examples.


<<>>=
library(Biobase)
data(sample.ExpressionSet)
sample.ExpressionSet
set.seed(1)
idx <- sample(seq_len(dim(sample.ExpressionSet)[1]), size = 50)
eset <- sample.ExpressionSet[idx,]
@ %def 

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default, fig = TRUE, fig.cap = "Heatmap default">>=
p1 <- autoplot(eset)
p1
@ %def 
%   \caption{Heatmap default}
%   \label{fig:eset-default}
% \end{figure}
% \clearpage

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default-scale, fig = TRUE, fig.cap = "Heatmap default with blue-white-red scale">>=
p2 <- p1 + scale_fill_fold_change()
p2
@ %def 
%   \caption{Heatmap default with blue-white-red scale}
%   \label{fig:eset-default-scale}
% \end{figure}
% \clearpage

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default-pcp, fig = TRUE, fig.cap = "Parallel coordinate plot.">>=
autoplot(eset, type = "pcp")
@ %def 
%   \caption{Parallel coordinate plot.}
%   \label{fig:eset-default-pcp}
% \end{figure}
% \clearpage

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default-boxplot, fig = TRUE>>=
autoplot(eset, type = "boxplot")
@ %def 
%   \caption{Boxplot.}
%   \label{fig:eset-default-boxplot}
% \end{figure}
% \clearpage

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default-sm, fig = TRUE, fig.cap = "Scatterplot matrix.">>=
autoplot(eset[, 1:7], type = "scatterplot.matrix")
@ %def 
%   \caption{Scatterplot matrix.}
%   \label{fig:eset-default-sm}
% \end{figure}
% \clearpage

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default-ms, fig = TRUE>>=
autoplot(eset, type = "mean-sd")
@ %def 
%   \caption{Scatterplot matrix.}
%   \label{fig:eset-default-ms}
% \end{figure}
% \clearpage

% \begin{figure}[!htbp]
%   \centering
% @ 
<<eset-default-volcano, fig = TRUE>>=
autoplot(eset, type = "volcano", fac = pData(sample.ExpressionSet)$type)
@ %def 
%   \caption{Scatterplot matrix.}
%   \label{fig:eset-default-volcano}
% \end{figure}
% \clearpage

\subsection{autoplot, SummarizedExperiment}
\Robject{SummarizedExperiment} is a eSet-like container, where column represetns
samples and rows represent ranges of interest, for example, a \Robject{GRanges}
object, and it could contain one or more assays. It's defined in package
\Rpackage{GenomicRanges}. 

\begin{itemize}
\item 'heatmap': default.  
\item 'pcp': parallel coordinate plots, level change for particular gene(row)
  can be easily observed cross samples.
\item 'boxplot': boxplot, summary over samples.
\item 'scatterplot.matrix' pairwised comparison across samples, a quick way to
  observe correlation.   
\end{itemize}


<<sset>>=
nrows <- 200; ncols <- 6
counts <- matrix(runif(nrows * ncols, 1, 1e4), nrows)
rowData <- GRanges(rep(c("chr1", "chr2"), c(50, 150)),
                   IRanges(floor(runif(200, 1e5, 1e6)), width=100),
                   strand=sample(c("+", "-"), 200, TRUE))
colData <- DataFrame(Treatment=rep(c("ChIP", "Input"), 3),
                     row.names=LETTERS[1:6])
sset <- SummarizedExperiment(assays=SimpleList(counts=counts),
                             rowData=rowData, colData=colData)




@ %def 

% \begin{figure}[!htpb]
%   \centering
% @ 
<<sset-heatmap, fig = TRUE>>=
autoplot(sset) + scale_fill_fold_change()
@ %def 
%   \caption{heatmap}
%   \label{fig:sset-heatmap}
% \end{figure}
% \clearpage


% \begin{figure}[!htpb]
%   \centering
% @ 
<<sset-pcp, fig = TRUE>>=
autoplot(sset, type = "pcp")
@ %def 
%   \caption{Parallel coordiante plot.}
%   \label{fig:sset-pcp}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering
% @ 
<<sset-boxplot, fig = TRUE>>=
autoplot(sset, type = "boxplot")
@ %def 
%   \caption{Boxplot.}
%   \label{fig:sset-boxplot}
% \end{figure}
% \clearpage


% \begin{figure}[!htpb]
%   \centering
% @ 
<<sset-sm, fig = TRUE>>=
autoplot(sset, type = "scatterplot.matrix")
@ %def 
%   \caption{Scatterplot matrix}
%   \label{fig:sset-sm}
% \end{figure}
% \clearpage


\subsection{autoplot,VCF}
\Robject{VCF}(Variant Call Format) class extends a class we have introduced
\Robject{SummarizedExperiment}, and with additional slots, 'fixed' and
'info'. It's defined in package \Rpackage{VariantAnnotation}. 

We have done some experimental visualization, and features are going to be
extended or changed later.
\begin{itemize}
\item For type 'geno': we get an assay, and test if 'GT' is in. Then we make a
  heatmap to show geno types.
\item For type 'info': Please specify one variable as y to show as bars.
\item For type 'fixed': You can plot ref/alt strings on the plot, default plot
  both reference and variants, and if one string is over 1, we will use a black
  'I' to indicate that's an indel, then if at each position there are multiple
  data, we will show them in different y levels. Argument \Rfunarg{full.string}
  control if you want to show full strings of indels or not, even they are shown
  as full string, they will still be in balck color, to indicate it's on the
  single position. \Rfunarg{ref.show} controls if you want to show REF column in
  the data or not, sometimes people may want to just plot \Robject{BSgenome}
  object as reference track.
\end{itemize}



<<vcf>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
hdr <- exptData(vcf)[["header"]]
@ %def 


% \begin{figure}[!htpb]
%   \centering
% @ 
<<va-default, fig = TRUE>>=
library(VariantAnnotation)
vcffile <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- readVcf(vcffile, "hg19")
gt <- geno(vcf)[['GT']]
sts <- start(rowData(vcf))
idx <- !duplicated(sts)
gt <- gt[idx,]
rownames(gt) <- start(rowData(vcf)[idx])
gt.t <- t(gt)
autoplot(gt.t)+ scale_x_continuous()
autoplot(gt.t, genomic.pos = TRUE) 
@ %def 
%   \caption{default heatmap to show GT for type 'geno'.}
%   \label{fig:va-default}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering
% @ 
<<va-info, fig = TRUE>>=
autoplot(vcf, type = "info", aes(y  = THETA))
@ %def 
%   \caption{default bar chart for type info, use THETA as y.}
%   \label{fig:va-info}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering
% @ 
<<va-fixed, fig = TRUE>>=
autoplot(vcf, type = "fixed")
@ %def 
%   \caption{default heatmap to show GT as heatmap for type 'fixed'.}
%   \label{fig:va-fixed}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering
% @ 
<<va-fs, fig = TRUE>>=
p1 <- autoplot(vcf, type = "fixed") + xlim(50310860, 50310890) 
p2 <- autoplot(vcf, type = "fixed", full.string = TRUE) + xlim(50310860, 50310890)
tracks("full.string = FALSE" = p1, "full.string = TRUE" = p2)+
  scale_y_continuous(breaks = NULL, limits = c(0, 3))
@ %def 
%   \caption{Demonstration of full.string. }
%   \label{fig:va-fs}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering
% @ 
<<va-rsw, fig = TRUE>>=
p3 <- autoplot(vcf, type = "fixed", ref.show = FALSE) + xlim(50310860, 50310890) +
    scale_y_continuous(breaks = NULL, limits = c(0, 2))
p3
@ %def 
%   \caption{Demonstration of ref.show. }
%   \label{fig:va-rs}
% \end{figure}
% \clearpage
\subsection{autoplot,BSgenome}
The \Robject{BSgenome} class is a container for the complete genome sequence of
a given organism, it's defined in package \Rpackage{BSgenome}. We use it to plot
reference genome, along with other tracks.
% \begin{figure}[!htpb]
%   \centering
% @ 
<<bs-v, fig = TRUE>>=
library(BSgenome.Hsapiens.UCSC.hg19)
data(genesymbol, package = "biovizBase")
p1 <- autoplot(Hsapiens, which = resize(genesymbol["ALDOA"], width = 50))
p2 <- autoplot(Hsapiens, which = resize(genesymbol["ALDOA"], width = 50), geom = "rect")
tracks(text = p1, rect = p2)
@ %def   
%   \caption{plot BSgenome}
%   \label{fig:bs-v}
% \end{figure}
\chapter{Ideogram}\label{chapter:ideogram}
\chapter{Circular view}\label{chapter:circle}
\section{Introduction}
Layout "circle" is inspired by \textit{Circos
  project}\footnote{http://circos.ca/}. We extended it into the grammar of
graphics and make it a general layout. Layout is generally more complex than a
coordinate transformation, it's a combination of different components like
coordinate transformation(genome and polar), and tracks-based layout,
etc. Especially, circular view is very useful to show links between different
locations. Since we are following the grammar of graphics, aesthetics mapping
are fairly easy in \ggbio{}.

In this tutorial, we will start from the raw data, if you are already familiar
with how to process your data into the right format, which here I mean
\Robject{GRanges},you can jump to \ref{sec:step3} directly.
\section{Tutorial}
\subsection{Step 1: understand the layout circle}
We have discussed about the new coordinate "genome" in vignette about Manhattan
plot before, now this time, it's one step further compared to genome coordinate
transformation. We specify ring radius \Rfunarg{radius} and track width
\Rfunarg{trackWidth} to help transform a linear genome coordinate system to a
circular coordinate system. By using \Rfunction{layout\_circle} function which we
will introduce later.

Before we visualize our data, we need to have something in mind
\begin{itemize}
\item How many tracks we want?
\item Can they be combined into the same data?
\item Do I have chromosomes lengths information?
\item Do I have interesting variables attached as one column?
\end{itemize}


\subsection{Step 2: get your data ready to plot}
Ok, let's start to process some raw data to the format we want. The data used in
this study is from this a
paper\footnote{http://www.nature.com/ng/journal/v43/n10/full/ng.936.html}. In
this example, We are going to
\begin{enumerate}
\item Visualize somatic mutation as segment.
\item Visualize inter,intro-chromosome rearrangement as links.
\item Visualize mutation score as point tracks with grid-background.
\item Add scale and ticks and labels.  
\item To arrange multiple plots and legend. create multiple sample comparison.
\end{enumerate}

Notes: don't put too much tracks on it.  


I simply put script here to get mutation data as `GRanges` object.


<<processing>>=
crc1 <- system.file("extdata", "crc1-missense.csv", package = "biovizBase")
crc1 <- read.csv(crc1)
library(GenomicRanges)
mut.gr <- with(crc1,GRanges(Chromosome, IRanges(Start_position, End_position),
                            strand = Strand))
values(mut.gr) <- subset(crc1, select = -c(Start_position, End_position, Chromosome))
data("hg19Ideogram", package = "biovizBase")
seqs <- seqlengths(hg19Ideogram)
## subset_chr
chr.sub <- paste("chr", 1:22, sep = "")
## levels tweak
seqlevels(mut.gr) <- c(chr.sub, "chrX")
mut.gr <- keepSeqlevels(mut.gr, chr.sub)
seqs.sub <- seqs[chr.sub]
## remove wrong position
bidx <- end(mut.gr) <= seqs.sub[match(as.character(seqnames(mut.gr)),
              names(seqs.sub))]
mut.gr <- mut.gr[which(bidx)]
## assign_seqlengths
seqlengths(mut.gr) <- seqs.sub
## reanme to shorter names
new.names <- as.character(1:22)
names(new.names) <- paste("chr", new.names, sep = "")
new.names
mut.gr.new <- renameSeqlevels(mut.gr, new.names)
head(mut.gr.new)
@ %def 

To get ideogram track, we need to load human hg19 ideogram data, for details
please check another vignette about getting ideogram.


<<ideo>>=
hg19Ideo <- hg19Ideogram
hg19Ideo <- keepSeqlevels(hg19Ideogram, chr.sub)
hg19Ideo <- renameSeqlevels(hg19Ideo, new.names)
head(hg19Ideo)
@ %def 

\subsection{Step 3: low level API: \Rfunction{layout\_circle}}\label{sec:step3}
\Rfunction{layout\_circle} is a lower level API for creating circular plot, it
accepts \Robject{Granges} object, and users need to specify radius, track width,
and other aesthetics, it's very flexible. But keep in mind, you \textbf{have to}
pay attention rules when you make circular plots.

\begin{itemize}
\item For now, \Rfunction{seqlengths}, \Rfunction{seqlevels} and chromosomes
  names should be exactly the same, so you have to make sure data on all tracks
  have this uniform information to make a comparison.
\item Set arguments \Rfunarg{space.skip} to the same value for all tracks, that
  matters for transformation, default is the same, so you don't have to change
  it, unless you want to add/remove space in between.
\item \Rfunarg{direction} argument should be exactly the same, either
  "clockwise" or "counterclockwise".
\item Tweak with your radius and tracks width to get best results.
\end{itemize}


Since low level API leave you as much flexibility as possible, this may looks
hard to adjust, but it can produce various types of graphics which higher levels
API like \autoplot{} hardly can, for instance, if you want to overlap multiple
tracks or fine-tune your layout.

Ok, let's start to add tracks one by one.

First to add a "ideo" track
% \begin{figure}[!htpb]
%   \centering

<<lower-ideo-track, fig = TRUE, fig.cap = "Adding 'ideogram' track.">>=
library(ggbio)
p <- ggplot() + layout_circle(hg19Ideo, geom = "ideo", fill = "gray70",
                              radius = 30, trackWidth = 4)
p
@ %def   
%   \caption{Adding 'ideogram' track.}
%   \label{fig:ideo}
% \end{figure}
% \clearpage

Then a "scale" track with ticks
% \begin{figure}[!htpb]
%   \centering
@ 
<<lower-scale-track, fig = TRUE, fig.cap = "Adding a 'scale' track.">>=
p <- p + layout_circle(hg19Ideo, geom = "scale", size = 2, radius = 35, trackWidth = 2)
p
@ %def   
%   \caption{Adding a 'scale' track.}
%   \label{fig:scale}
% \end{figure}
% \clearpage

Then a "text" track to label chromosomes. *NOTICE*, after genome coordinate
transformation, original data will be stored in column ".ori", and for mapping,
just use ".ori" prefix to it. Here we use `.ori.seqnames`, if you use
`seqnames`, that is going to be just "genome" character.
% \begin{figure}[!htpb]
%   \centering

<<lower-text-track, fig = TRUE, fig.cap = "Adding a 'text' track.">>=
p <- p + layout_circle(hg19Ideo, geom = "text", aes(label = seqnames), vjust = 0,
                       radius = 38, trackWidth = 7)
p
@ %def 
%   \caption{Adding a 'text' track.}
%   \label{fig:text}
% \end{figure}
% \clearpage

Then a "rectangle" track to show somatic mutation, this will looks like vertical
segments. 
% \begin{figure}[!htpb]
%   \centering

<<lower-mut-track, fig = TRUE, fig.cap = "Adding a segment track to show mutation.">>=
p <- p + layout_circle(mut.gr, geom = "rect", color = "steelblue",
                       radius = 23 ,trackWidth = 6)
p
@ %def   
%   \caption{Adding a segment track to show mutation.}
%   \label{fig:mut}
% \end{figure}
% \clearpage

Next, we need to add some "links" to show the rearrangement, of course, links
can be used to map any kind of association between two or more different
locations to indicate relationships like copies or fusions.


<<links>>=
rearr  <- read.csv(system.file("extdata", "crc-rearrangment.csv", package = "biovizBase"))
## start position
gr1 <- with(rearr, GRanges(chr1, IRanges(pos1, width = 1)))
## end position
gr2 <- with(rearr, GRanges(chr2, IRanges(pos2, width = 1)))
## add extra column
nms <- colnames(rearr)
.extra.nms <- setdiff(nms, c("chr1", "chr2", "pos1", "pos2"))
values(gr1) <- rearr[,.extra.nms]
## remove out-of-limits data
seqs <- as.character(seqnames(gr1))
.mx <- seqlengths(hg19Ideo)[seqs]
idx1 <- start(gr1) > .mx
seqs <- as.character(seqnames(gr2))
.mx <- seqlengths(hg19Ideo)[seqs]
idx2 <- start(gr2) > .mx
idx <- !idx1 & !idx2
gr1 <- gr1[idx]
seqlengths(gr1) <- seqlengths(hg19Ideo)
gr2 <- gr2[idx]
seqlengths(gr2) <- seqlengths(hg19Ideo)
@ %def 

To create a suitable structure to plot, please use another `GRanges` to
represent the end of the links, and stored as elementMetadata for the "start
point" `GRanges`. Here we named it as "to.gr" and will be used later.
 
<<link-data>>=
values(gr1)$to.gr <- gr2
## rename to gr
gr <- gr1
@ %def 

Here we show the flexibility of *ggbio*, for example, if you want to use color
to indicate your links, make sure you add extra information in the data, used
for mapping later. Here in this example, we use "intrachromosomal" to label
rearrangement within the same chromosomes and use "interchromosomal" to label
rearrangement in different chromosomes.
 
<<rearr>>=
values(gr)$rearrangements <- ifelse(as.character(seqnames(gr))
                                    == as.character(seqnames((values(gr)$to.gr))),
                                    "intrachromosomal", "interchromosomal")
@ %def 

Get subset of links data for only one sample "CRC1"
 
<<subset-crc-1>>=
gr.crc1 <- gr[values(gr)$individual == "CRC-1"]
@ %def 

Ok, add a "point" track with grid background for rearrangement data and map `y`
to variable "score", map `size` to variable "tumreads", rescale the size to a
proper size range.
 
<<lower-point-track, fig = TRUE>>=
p <- p + layout_circle(gr.crc1, geom = "point", aes(y = score, size = tumreads), color = "red",
                       radius = 12 ,trackWidth = 10, grid = TRUE) +
  scale_size(range = c(1, 2.5))
p
@ %def 

% \clearpage
Finally, let's add links and map color to rearrangement types. Remember you need
to specify `linked.to` to the column that contain end point of the data.
% \begin{figure}[!htpb]
%   \centering
 
<<lower-link-track, fig = TRUE, fig.cap = "A link track is added to the circular plot.">>=
p <- p + layout_circle(gr.crc1, geom = "link", linked.to = "to.gr", aes(color = rearrangements),
                       radius = 10 ,trackWidth = 1)
p
@ %def   
%   \caption{A link track is added to the circular plot.}
%   \label{fig:links}
% \end{figure}

\subsection{Step 4: Complex arragnment of plots}
In this step, we are going to make multiple sample comparison, this may require
some knowledge about package \Rpackage{grid} and \Rpackage{gridExtra}. We will
introduce a more easy way to combine your graphics later after this.

We just want 9 single circular plots put together in one page, since we cannot
keep too many tracks, we only keep ideogram and links. Here is one sample.
% \begin{figure}[!htpb]
%   \centering
 
<<single-arr, fig = TRUE, fig.cap = "Just to show single individuals crc1.">>=
cols <- RColorBrewer::brewer.pal(3, "Set2")[2:1]
names(cols) <- c("interchromosomal", "intrachromosomal")

p0 <- ggplot() + layout_circle(gr.crc1, geom = "link", linked.to = "to.gr",
                              aes(color = rearrangements), radius = 7.1) +
  layout_circle(hg19Ideo, geom = "ideo", trackWidth = 1.5,
                color = "gray70", fill = "gray70") +
  scale_color_manual(values = cols)  
p0
@ %def   
%   \caption{Just to show single individuals crc1.}
%   \label{fig:single-arr}
% \end{figure}


We need to get one legend for all of them, and put it on the right, ok, that's a
little tricky, we can first store the legend from the plot we just created.


 
<<legend>>=
library(gridExtra)
g = ggplotGrob(p0)
gg = editGrob(getGrob(g, gPath("guide-box"), 
  grep=TRUE), vp=viewport())
@ %def 
Start to creating plots for each sample.

 
<<arrangement>>=
grl <- split(gr, values(gr)$individual)
## need "unit", load grid
library(grid)
lst <- lapply(grl, function(gr.cur){
  print(unique(as.character(values(gr.cur)$individual)))
  cols <- RColorBrewer::brewer.pal(3, "Set2")[2:1]
  names(cols) <- c("interchromosomal", "intrachromosomal")
  p <- ggplot() + layout_circle(gr.cur, geom = "link", linked.to = "to.gr",
                         aes(color = rearrangements), radius = 7.1) +
                           layout_circle(hg19Ideo, geom = "ideo", trackWidth = 1.5,
                         color = "gray70", fill = "gray70") +
                           scale_color_manual(values = cols)  + 
     theme(title = (unique(values(gr.cur)$individual))) +
    theme(plot.margin = unit(rep(0, 4), "lines"))
})
lst.nolegend <- lapply(lst, function(p) p + theme(legend.position = "none"))
l.g <- lapply(lst.nolegend, ggplotGrob)
@ %def
\clearpage 

Use package \Rpackage{gridExtra} to arrange them and add legend to the right.
\begin{figure}[!htpb]
  \centering
 
<<9-circle, fig = TRUE>>=
grid.arrange(do.call(arrangeGrob, l.g), gg, ncol = 2, widths = c(4/5, 1/5))
@ %def   
  \caption{Arrange 9 circles together.}
  \label{fig:9circle}
\end{figure}

We wrap the function in grid level to a more user-friendly high level function,
called \Rfunction{arrangeGrobByParsingLegend}. You can pass your ggplot2
graphics to this function , specify the legend you want to keep on the right,
you can also specify the column/row numbers. Here we assume all plots we have
passed follows the same color scale and have the same legend, so we only have to
keep one legend on the right.

 
<<simple-wrapper, fig = TRUE>>=
arrangeGrobByParsingLegend(lst, widths = c(4, 1), legend.idx = 1, ncol = 2)
@ %def   

\chapter{Manhattan plot}
\section{Introduction}
In this tutorial, we introduce a new coordinate system called "genome" for
genomic data. This transformation is to put all chromosomes on the same genome
coordinates following specified orders and adding buffers in between.  One may
think about facet ability based on \textit{seqnames}, it can produce something
similar to \textit{Manhattan
  plot}\footnote{http://en.wikipedia.org/wiki/Manhattan}, but the view will not
be compact. What's more, genome transformation is previous step to form a
circular view. In this tutorial, we will simulate some SNP data and use this
special coordinate and a specialized function \Rfunction{plotGrandLinear} to
make a Manhattan plot.

\textit{Manhattan plot} is just a special use design with this coordinate system.

\section{Understand the new coordinate}
Let's load some packages and data first
 
<<load>>=
library(ggbio)
data(hg19IdeogramCyto, package = "biovizBase")
data(hg19Ideogram, package = "biovizBase")
library(GenomicRanges)
@ %def 


Make a minimal example `GRanges`, and see what the default coordiante looks
like, pay attention that, by default, the graphics are faceted by `seqnames` as
shown in Figure \ref{fig:simul_gr}
% \begin{figure}[!htpb]
%   \centering
 
<<simul_gr, fig = TRUE, fig.cap = "Default grahpics is faceted by seqnames", fig.height = 4>>=
library(biovizBase)
gr <- GRanges(rep(c("chr1", "chr2"), each = 5),
              IRanges(start = rep(seq(1, 100, length = 5), times = 2),
                      width = 50))
autoplot(gr, aes(fill = seqnames))
@ %def 
%   \caption{Default grahpics is faceted by seqnames}
%   \label{fig:simul_gr}
% \end{figure}

What if we specify the coordinate system to be "genome" in \autoplot{} function,
there is no faceting anymore, the two plots are merged into one single genome
space, and properly labeled as shown in Figure \ref{fig:coord-genome}
% There is a limitation on integer in \R{}, so the
% genome space cannot be too long, to overcome this limitation, a default argument
% called `maxSize` is defined with this function, if the genome space is over
% limits, it will rescale everything automatically, function `tranformToGenome`
% with return a transformed `GRanges` object, with only one single `seqnames`
% called "genome" and the `seqlengths` of it, is just genome space(with buffering
% region). arguments called `space.ratio` control the skipped region between
% chromosomes.

% \begin{figure}[!htpb]
%   \centering
 
<<coord-genome, fig = TRUE, fig.cap = "Coordinate genome", fig.height = 4>>=
autoplot(gr, coord = "genome", aes(fill = seqnames))
@ %def   
%   \caption{Coordinate genome}
%   \label{fig:coord-genome}
% \end{figure}


The internal transformation are implemented into the function
\Rfunction{transformToGenome}. And there is some simple way to test if a
\Robject{GRanges} object is transformed to coordinate "genome" or not

 
<<is>>=
gr.t <- transformToGenome(gr)
head(gr.t)
is_coord_genome(gr.t)
metadata(gr.t)$coord
@ %def 


\section{Step 2: Simulate a SNP data set}
Let's use the real human genome space to simulate a SNP data set.
 
<<simul_snp>>=
chrs <- as.character(levels(seqnames(hg19IdeogramCyto)))
seqlths <- seqlengths(hg19Ideogram)[chrs]
set.seed(1)
nchr <- length(chrs)
nsnps <- 100
gr.snp <- GRanges(rep(chrs,each=nsnps),
                  IRanges(start =
                          do.call(c, lapply(chrs, function(chr){
                            N <- seqlths[chr]
                            runif(nsnps,1,N)
                          })), width = 1),
                  SNP=sapply(1:(nchr*nsnps), function(x) paste("rs",x,sep='')),
                  pvalue =  -log10(runif(nchr*nsnps)),
                  group = sample(c("Normal", "Tumor"), size = nchr*nsnps,
                    replace = TRUE)
                  )
genome(gr.snp) <- "hg19"
gr.snp
@ %def 


We use the some trick to make a shorter names.
 
<<shorter>>=
seqlengths(gr.snp)
nms <- seqnames(seqinfo(gr.snp))
nms.new <- gsub("chr", "", nms)
names(nms.new) <- nms
gr.snp <- renameSeqlevels(gr.snp, nms.new)
seqlengths(gr.snp)
@ %def 


\section{Step 3: Start to make Manhattan plot by using \autoplot{}}
wrapped basic functions into \autoplot{}, you can specify the coordinate. Figure
\ref{fig:unorder} shows what the unordered object looks like.
% \begin{figure}[!htpb]
%   \centering
 
<<unorder, fig = TRUE, fig.height = '0.5\textwidth', fig.cap = "Unordred Manhattan plot", fig.height = 4>>=
autoplot(gr.snp, coord = "genome", geom = "point", aes(y = pvalue), space.skip = 0.01)
@ %def   
%   \caption{Unordred Manhattan plot}
%   \label{fig:unorder}
% \end{figure}


That's probably not what you want, if you want to change to specific order, just
sort them by hand and use `keepSeqlevels`. Figure \ref{fig:sort} shows a sorted
plot.
% \begin{figure}[!htpb]
%   \centering

<<sort, fig = TRUE, fig.cap = "Sorted data for Manhattan plot", fig.height = 4>>=
gr.snp <- keepSeqlevels(gr.snp, c(1:22, "X", "Y"))
autoplot(gr.snp, coord = "genome", geom = "point", aes(y = pvalue), space.skip = 0.01)
@ %def 
%   \caption{Sorted data for Manhattan plot}
%   \label{fig:sort}
% \end{figure}


\textbf{NOTICE}: the data now doesn't have information about lengths of each
chromosomes, this is allowed to be plotted, but it's misleading sometimes,
without chromosomes lengths information, \ggbio{} use data space to make
estimated lengths for you, this is not accurate! So let's just assign
\Rfunction{seqlengths} to the object. Then you will find the data space now is
distributed proportional to real space as shown in Figure \ref{fig:with-seql}.

% \begin{figure}[!htpb]
%   \centering
 
<<with_seql, fig = TRUE, fig.cap = "Manhattan plot after setting seqlengths to the data, the data space now is distributed proportional to real chromosome space.", fig.height = 4>>=
names(seqlths) <- gsub("chr", "", names(seqlths))
seqlengths(gr.snp) <- seqlths[names(seqlengths(gr.snp))]
autoplot(gr.snp, coord = "genome", geom = "point", aes(y = pvalue), space.skip = 0.01)
@ %def 
%   \caption{Manhattan plot after setting seqlengths to the data, the data space now is
%     distributed proportional to real chromosome space.}
% \label{fig:with-seql}
% \end{figure}

In \autoplot{}, argument \Rfunarg{coord} is just used to transform the data,
after that, you can use it as common \Robject{GRanges}, all other geom/stat
works for it. Here just show a simple example for another geom "line" as shown
in Figure \ref{fig:line}

% \begin{figure}[!htpb]
%    \centering
<<line, fig = TRUE, fig.height = 4, fig.cap = "Use line to represent the data in typical Manhattan plot.">>=
autoplot(gr.snp, coord = "genome", geom = "line", aes(y = pvalue, group = seqnames,
                                     color = seqnames))
@  %def   
%   \caption{Use line to represent the data in typical Manhattan plot.}
%   \label{fig:line}
% \end{figure}




\section{Convenient \Rfunction{plotGrandLinear} function}
In \ggbio{}, sometimes we develop specialized function for certain types of
plots, it's basically a wrapper over lower level API and \autoplot{}, but more
convenient to use. Here for \textit{Manhattan plot}, we have a function called
\Rfunction{plotGrandLinear} used for it. aes(y = ) is required to indicate the y
value, e.g.  p-value. Figure \ref{fig:plotGl} shows a defalut graphic.
% \begin{figure}[!htpb]
%   \centering
 
<<plotGrandLinear, fig = TRUE, fig.height = 4, fig.cap = "Default Manhattan plot by calling plotGrandLinear function">>=
plotGrandLinear(gr.snp, aes(y = pvalue))
@ %def   
%   \caption{Default Manhattan plot by calling plotGrandLinear function}
%   \label{fig:plotGl}
% \end{figure}


Color mapping is automatically figured out by *ggbio* following the rules
\begin{itemize}
\item if \Rfunarg{color} present in \Rcode{aes()}, like \Rcode{aes(color =
    seqnames)}, it will assume it's mapping to data column called 'seqnames'.
\item if \Rfunarg{color} is not wrapped in \Rcode{aes()}, then this function
  will \textbf{recylcle} them to all chromosomes.
\item if \Rfunarg{color} is single character representing color, then just use
  one arbitrary color.
\end{itemize}
 
Let's test some examples for controling colors.
% \begin{figure}[!htpb]
%   \centering
 
<<morecolor1, fig = TRUE, fig.height = 4, fig.cap = "Color mapped to chromosome names.">>=
plotGrandLinear(gr.snp, aes(y = pvalue, color = seqnames))
@ %def   
%   \caption{Color mapped to chromosome names.}
%   \label{fig:more1}
% \end{figure}

% \begin{figure}[!htpb]
%   \centering
 
<<morecolor2, fig = TRUE, fig.height = 4, fig.cap = "Color follow 'green' and 'deepskyblue' order for all chromosome space.">>=
plotGrandLinear(gr.snp, aes(y = pvalue), color = c("green", "deepskyblue"))
@ %def   
%   \caption{Color follow 'green' and 'deepskyblue' order for all chromosome space.}
%   \label{fig:more2}
% \end{figure}

% \begin{figure}[!htpb]
%   \centering
 
<<morecolor3, fig = TRUE, fig.height = 4, fig.cap = "Color follow three colors pattern: 'green','deepskyblue', 'red'">>=
plotGrandLinear(gr.snp, aes(y = pvalue), color = c("green", "deepskyblue", "red"))
@ %def   
% \caption{Color follow three colors pattern: 'green','deepskyblue', 'red'}
%   \label{fig:more3}
% \end{figure}

% \begin{figure}[!htpb]
%   \centering
 
<<morecolor4, fig = TRUE, fig.height = 4, fig.cap = "Unique color for all.">>=
plotGrandLinear(gr.snp, aes(y = pvalue), color = "red")
@ %def   
%   \caption{Unique color for all.}
%   \label{fig:more4}
% \end{figure}


You can also add cutoff line as shown in Figure \ref{fig:cutoff}.
 % \begin{figure}[!htpb]
 %   \centering
<<cutoff, fig = TRUE, fig.height = 4, fig.cap = "Set cutoff on the Manhattan plot. The 'blue' line shows cutoff at value 3.">>=
plotGrandLinear(gr.snp, aes(y = pvalue), cutoff = 3, cutoff.color = "blue", cutoff.size = 4)
@ %def   
%   \caption{Set cutoff on the Manhattan plot. The 'blue' line shows cutoff at value 3.}
%   \label{fig:cutoff}
% \end{figure}


This is equivalent to \ggplot{} 's API.
 
<<cutoff-low, eval = FALSE>>=
plotGrandLinear(gr.snp, aes(y = pvalue)) + geom_hline(yintercept = 3, color = "blue", size = 4)
@ %def 

Sometimes the names of chromosomes maybe very long, you may want to rotate them, 
let's make a longer name first
 
<<longer>>=
## let's make a long name
nms <- seqnames(seqinfo(gr.snp))
nms.new <- paste("chr00000", nms, sep = "")
names(nms.new) <- nms
gr.snp <- renameSeqlevels(gr.snp, nms.new)
seqlengths(gr.snp)
@ %def 

Then rotate it!
 % \begin{figure}[rotate]
 %   \centering
<<rotate, fig = TRUE, fig.height = 4>>=
plotGrandLinear(gr.snp, aes(y = pvalue)) + theme(axis.text.x=theme_text(angle=-90, hjust=0))
@ %def   
%   \caption{Rotate the x lable to save space.}
%   \label{fig:rotate}
% \end{figure}

% \clearpage
As you can tell from above examples, all utilities works for \ggplot{} will work
for \ggbio{} too.

\chapter{Karyogram overview}
\section{Introduction}
A karyotype is the number and appearance of chromosomes in the nucleus of a
eukaryotic cell\footnote{http://en.wikipedia.org/wiki/Karyotype}. It's one
overview option when we want to show distribution of certain events on the
genome, for example, binding sites for one protein. Particular pattern might be
easier to observe from graphics, such as
\begin{itemize}
\item Clusterred events.
\item Large missing chunk of data on particular chromosome.
\end{itemize}

\Robject{GRanges} object is also an ideal container for storing data needed for
karyogram plot. Here is the strategy we used for generating ideogram templates.
\begin{itemize}
\item \Robject{seqlengths} is not required, but highly recommended for plotting
  karyogram. If a \Robject{GRanges} object contains \Robject{seqlengths}, we
  know exactly how long each chromosome is, and will use this information to
  plot genome space, particularly we plot all levels included in it, not just
  DATA space.
\item If a \Robject{GRanges} has no \Robject{seqlengths}, we will issue a
  warning and try to estimate the chromosome lengths from data included. This is
  NOT accurate most time, so please pay attention to what you are going to
  visualize and make sure set \Robject{seqlengths} before hand.
\end{itemize}

\section{Usage}
\subsection{\Rfunction{autoplot}}
Let's first introduce how to use \autoplot{} to generate karyogram graphic. To
understand why we call it kayogram, let's first visualize some cytoband. We use
\Rfunarg{layout} argument to specify this special layout "karyogram". And under
this layout, \Rfunarg{cytoband} argument is acceptable, default is
\Rcode{FALSE}, if set to \Rcode{TRUE}, we assume your have additional
information associated with the data, stored in column \Rcode{gieStain}, it will
try to fill colors based on this variable according to a pre-set staining
colors. You may notice, this data set doesn't contain seqlengths information,
but the data space actually cover the real space, so it's not going to be a
problem. 

 
<<loading>>=
library(ggbio)
data(hg19IdeogramCyto, package = "biovizBase")
head(hg19IdeogramCyto)
## default pre-set color stored in 
getOption("biovizBase")$cytobandColor
@ %def 

<<default, fig = TRUE>>=
autoplot(hg19IdeogramCyto, layout = "karyogram", cytoband = TRUE) 
@ %def   

You may want to change the order of chromosomes, \Rfunction{keepSeqlevels} are
convenient for this purpose, it's defined in package \Rpackage{GenomicRanges}.

% \begin{figure}[!htpb]
%   \centering
 
<<change-order, fig = TRUE>>=
library(GenomicRanges)
hg19 <- keepSeqlevels(hg19IdeogramCyto, paste0("chr", c(1:22, "X", "Y")))
head(hg19)
autoplot(hg19, layout = "karyogram", cytoband = TRUE)
@ %def   
%   \caption{Cytoband on karyogram layout after re-ordering the chromosome names.}
%   \label{fig:cytoband-reorder}
% \end{figure}


This \Robject{GRanges} object is special, it's a 'ideogram' we expected, in this
case, \Rfunarg{cytoband} argument could set to \Rcode{TRUE}, and we draw special
ideogram not just rectangles but show centromere as possible.

If we set it to \Rcode{FALSE}, we treat it as a normal \Robject{GRanges},
nothing special as ideogram. So to show the cytoband, we need to specify which
color column variable to fill as cytoband, function \Rfunction{aes} use an
unevaluated expression like \Rcode{fill = gieStain}, \textit{gieStain} is column
name which store cytoband color, notice that we don't use quotes around it, this
means it's not something defined globally, but some column name defined in the
data. The system will usually automatically assign categorical colors to
represent this variable. But instead, cytoband already have some pre-defined
colors which mimic the color you observed under microscope. Function
\Rfunction{scale\_fill\_giemsa} did this trick to correct the color. If it's
first time you observe usage by \Rcode{+}, it's a very popular API in package
\ggplot{}\footnote{http://had.co.nz/ggplot2/}, which could add graphics layer by
layer or revise a existing graphic.
% \begin{figure}[!htpb]
%   \centering
 
<<cyto-normal, fig = TRUE>>=
library(GenomicRanges)
## it's a 'ideogram'
biovizBase::isIdeogram(hg19)
## set to FALSE
autoplot(hg19, layout = "karyogram", cytoband = FALSE, aes(fill = gieStain)) +
  scale_fill_giemsa()
@ %def   
% \caption{Cytoband on karyogram layout. We treat it as normal \Robject{GRanges}
%   data set, so we fill with gieStain color, and use
%   \Rfunction{scale\_fill\_giemsa} to use customized color. Notice the difference
%   if it's not a 'ideogram' object. we don't draw centromere particularly.}
% \label{fig:cytoband-custom}
% \end{figure}
% \clearpage

Let's try a different data set which is not an 'ideogram', but a normal
\Robject{GRanges} object that most people will have, extra data such as
statistical values or categorical levels are stored in element data columns used
for aesthetics mapping.

We use a default data in package \Rpackage{biovizBase}, which is a subset of RNA
editing set in human. The data involved in this \Robject{GRanges} is sparse, so
we cannot simply use it to make karyogram, otherwise, the estimated chromosome
lengths will be very rough and inaccurate. So what we need to do is:
\begin{enumerate}
\item Adding seqlegnths to this \Robject{GRanges} object. If you adding
  seqlengths to object, we have two ways to show chromosome space as karyogram. 
  \\\Rcode{autoplot(object, layout = 'karyogram')} or 
  \\\Rcode{autoplot(seqinfo(object))}.
\item Changing the order of chromosomes.  
\item Visualize it and map variable to different aesthetics.  
\end{enumerate}

% \begin{figure}[!htpb]
%   \centering
 
<<load-RNAediting, fig = TRUE>>=
data(darned_hg19_subset500, package = "biovizBase")
dn <- darned_hg19_subset500
head(dn)
## add seqlengths
## we have seqlegnths information in another data set
data(hg19Ideogram, package = "biovizBase")
seqlengths(dn) <- seqlengths(hg19Ideogram)[names(seqlengths(dn))]
## now we have seqlengths
head(dn)
## then we change order
dn <- keepSeqlevels(dn, paste0("chr", c(1:22, "X")))
autoplot(dn, layout = "karyogram")
## this equivalent to 
## autoplot(seqinfo(dn))
@ %def   
% \caption{Default karyogram for non-ideogram \Robject{GRanges} object, in this
%   example, it's a subset of human RNA-editing sites, default is to use
%   seqlengths information or esitmated seqlengths information to plot a white
%   background, then plot actual data(interval or single position) as rectangle or
%   segment. Default color is just black. }
%   \label{fig:RNA-editing-default}
% \end{figure}
% \clearpage

Then we take one step further, the power of \ggplot{} or \ggbio{} is the
flexible multivariate data mapping ability in graphics, make data exploration
much more convenient. In the following example, we are trying to map a
categorical variable 'exReg' to color, this variable is included in the data,
and have three levels, '3' indicate 3' utr, '5' means 5' utr and 'C' means
coding region. We have some missing values indicated as \Rcode{NA}, in default,
it's going to be shown in gray color, and keep in mind, since the basic
geom(geometric object) is rectangle, and genome space is very large, so change
both color/fill color of the rectangle to specify both border and filled color
is necessary to get the data shown as different color, otherwise if the region
is too small, border color is going to override the fill color.
% \begin{figure}[!htpb]
%   \centering
 
<<load-RNAediting-color, fig = TRUE>>=
## since default is geom rectangle, even though it's looks like segment
## we still use both fill/color to map colors
autoplot(dn, layout = "karyogram", aes(color = exReg, fill = exReg))
@ %def   
% \caption{Karyogram for RNA-editing sites, and map color to exReg column, which
%   means exon region. '3' indicate 3' utr, '5' means 5' utr and 'C' means coding
%   region, NA indicate missing value(or not in other three levels) shown as gray
%   color.}
%   \label{fig:exReg}
% \end{figure}
% \clearpage

Or you can set the missing value to particular color you want.
% \begin{figure}[!htpb]
%   \centering
 
<<load-RNAediting-color-NA, fig = TRUE>>=
## since default is geom rectangle, even though it's looks like segment
## we still use both fill/color to map colors
autoplot(dn, layout = "karyogram", aes(color = exReg, fill = exReg)) +
  scale_color_discrete(na.value = "brown")
@ %def   
% \caption{Karyogram for RNA-editing sites, and map color to exReg column, which
%   means exon region. '3' indicate 3' utr, '5' means 5' utr and 'C' means coding
%   region, we force the missing value(NA) shown as brown color.}
%   \label{fig:exReg-NA}
% \end{figure}
% \clearpage

A test could be performed to demonstrate why 'seqlengths' of object
\Robject{GRanges} is important. Let's assume we set wrong chromosome lengths by
accident, lengths are all equal to chromosome 1. We arbitrarily set it to the
same number so that every chromosome are of equal length. From Figure
\ref{fig:exReg-NA-fake}, it's clear that this will affect what we see. So please
make sure 
\begin{itemize}
\item You get data space cover exactly the same chromosome space for each
  chromosome. or
\item You set the seqlengths to the right number.
\end{itemize}
Otherwise you will see weird pattern from your results, so actually it's a good
way to test your raw data too, if you raw data have something beyond chromosome
space, you need to dig into it to see what happened.


% \begin{figure}[!htpb]
%   \centering
 
<<load-RNAediting-color-fake, fig = TRUE>>=
dn2 <- dn
seqlengths(dn2) <- rep(max(seqlengths(dn2)), length(seqlengths(dn2)) )
autoplot(dn2, layout = "karyogram", aes(color = exReg, fill = exReg)) 
@ %def   
% \caption{Karyogram for RNA-editing sites, and map color to exReg column, which
%   means exon region. '3' indicate 3' utr, '5' means 5' utr and 'C' means coding
%   region, we force the missing value(NA) shown as brown color.}
%   \label{fig:exReg-NA-fake}
% \end{figure}
% \clearpage

\subsection{\Rfunction{plotKaryogram}}
\Rfunction{plotKaryogram} (or \Rfunction{plotStackedOverview}) are specialized
function to draw karyogram graphics. It's actually what function \autoplot{}
calls inside. API is a littler simpler because layout 'karyogram' is default in
these two functions. So equivalent usage is like
 
<<plotKaryogram, eval = FALSE>>=
plotKaryogram(dn)
plotKaryogram(dn, aes(color = exReg, fill = exReg))
@ %def 

\subsection{\Rfunction{layout\_karyogram}}
In this section, a lower level function \Rfunction{layout\_karyogram} is going
to be introduced. This is convenient API for constructing karyogram plot and
adding more data layer by layer. Function \Rfunction{ggplot} is just to create
blank object to add layer on.

You need to pay attention to 
\begin{itemize}
\item when you add plots layer by layer, seqnames of different data must be the
  same to make sure the data are mapped to the same chromosome. For example, if
  you name chromosome following schema like \textit{chr1} and use just number
  \textit{1} to name other data, they will be treated as different chromosomes.
\item cannot use the same aesthetics mapping multiple time for different
  data. For example, if you have used aes(color = ), for one data, you cannot
  use aes(color = ) anymore for mapping variables from other add-on data, this
  is currently not allowed in \ggplot{}, even though you expect multiple color
  legend shows up, this is going to confuse people which is which. HOWEVER,
  \Rfunarg{color} or \Rfunarg{fill} without \Rcode{aes()} wrap around, is
  allowed for any track, it's set single arbitrary color. This is shown in
  Figure \ref{fig:low-default-addon}
\item Default rectangle y range is [0, 10], so when you add on more data layer
  by layer on existing graphics, you can use \Rfunarg{ylim} to control how to
  normalize your data and plot it relative to chromosome space. For example,
  with default, chromosome space is plotted between y [0, 10], if you use
  \Rcode{ylim = c(10 , 20)}, you will stack data right above each chromosomes
  and with equal width. For geom like 'point', which you need to specify 'y'
  value in \Rcode{aes()}, we will add 5\% margin on top and at bottom of that
  track.
\end{itemize}

% \begin{figure}[!htpb]
%   \centering
 
<<low-default, fig = TRUE>>=
## plot ideogram
p <- ggplot() + layout_karyogram(hg19, cytoband = TRUE)
p
## eqevelant autoplot(hg19, layout = "karyogram", cytoband = TRUE)
@ %def   
%   \caption{Ideogram overview by using the function layout\_karyogram}
%   \label{fig:low-default}
% \end{figure}
% \clearpage

% \begin{figure}[!htpb]
%   \centering
 
<<low-default-addon, fig = TRUE>>=
p <- p + layout_karyogram(dn, geom = "rect", ylim = c(11, 21), color = "red")
## commented line below won't work
## the cytoband fill color has been used already.
## p <- p + layout_karyogram(dn, aes(fill = exReg, color = exReg), geom = "rect")
p
@ %def   
% \caption{We layout another track(data) which is RNA-editing sites on top of
%   ideogram. Notice since legend fill and color is used, we cannot specify that
%   in RNA-editing track, we could only set it to arbitrary color.}
%   \label{fig:low-default-addon}
% \end{figure}



Then we construct another multiple layer graphics for multiple data using
different geom, suppose we want to show RNA-editing sites on chromosome space as
rectangle(looks like segment in graphic) and stack a line for another track
above. 

% \begin{figure}[!htpb]
%   \centering
<<edit-space, fig = TRUE>>=
## plot chromosome space
p <- autoplot(seqinfo(dn))
## make sure you pass rect as geom
## otherwise you just get background
p <- p + layout_karyogram(dn, aes(fill = exReg, color = exReg), geom = "rect")
values(dn)$pvalue <- rnorm(length(dn))
p + layout_karyogram(dn, aes(x = start, y = pvalue), 
                     ylim = c(10, 30), geom = "line", color = "red")
p
@ %def 
%   \caption{Using Seqinfo to generate a white chromosome space, then adding
%     RNA-editing site and then use a fake value to shown as lines.}
%   \label{fig:edit-space}
% \end{figure}

\chapter{Case studies}
\section{Chip-seq}
\chapter{Reference}
\chapter{Appendix}
\section{Session Information}
 
<<session-info>>=
sessionInfo()
@ %def 


\end{document}

